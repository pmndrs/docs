{"version":3,"sources":["turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.browser.production.js","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/compiled/react-server-dom-turbopack/client.browser.js","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/html-bots.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/is-bot.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/is-thenable.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/use-action-queue.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/app-call-server.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/app-find-source-map-url.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/app-paths.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/interception-routes.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/match-segments.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/handle-mutable.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/segment-cache/segment-value-encoding.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/route-params.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/flight-data-helpers.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/app-build-id.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/hash.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/app-router-types.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/types.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/lru.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/cache-map.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/vary-path.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/cache-key.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/scheduler.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/parse-path.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/add-path-prefix.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/remove-trailing-slash.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/normalize-trailing-slash.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/add-base-path.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/app-router-utils.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/links.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/promise-with-resolvers.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/cache.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/navigation.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/reducers/refresh-reducer.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/reducers/server-patch-reducer.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/reducers/restore-reducer.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/assign-location.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/path-has-prefix.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/has-base-path.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/remove-base-path.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/server-reference-info.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/action-revalidation-kind.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/reducers/server-action-reducer.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/router-reducer/router-reducer.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/segment-cache/prefetch.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/app-router-instance.ts"],"sourcesContent":["/**\n * @license React\n * react-server-dom-turbopack-client.browser.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar ReactDOM = require(\"react-dom\"),\n  decoderOptions = { stream: !0 },\n  hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction resolveClientReference(bundlerConfig, metadata) {\n  if (bundlerConfig) {\n    var moduleExports = bundlerConfig[metadata[0]];\n    if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))\n      moduleExports = bundlerConfig.name;\n    else {\n      bundlerConfig = moduleExports && moduleExports[\"*\"];\n      if (!bundlerConfig)\n        throw Error(\n          'Could not find the module \"' +\n            metadata[0] +\n            '\" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'\n        );\n      moduleExports = metadata[2];\n    }\n    return 4 === metadata.length\n      ? [bundlerConfig.id, bundlerConfig.chunks, moduleExports, 1]\n      : [bundlerConfig.id, bundlerConfig.chunks, moduleExports];\n  }\n  return metadata;\n}\nfunction resolveServerReference(bundlerConfig, id) {\n  var name = \"\",\n    resolvedModuleData = bundlerConfig[id];\n  if (resolvedModuleData) name = resolvedModuleData.name;\n  else {\n    var idx = id.lastIndexOf(\"#\");\n    -1 !== idx &&\n      ((name = id.slice(idx + 1)),\n      (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));\n    if (!resolvedModuleData)\n      throw Error(\n        'Could not find the module \"' +\n          id +\n          '\" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'\n      );\n  }\n  return resolvedModuleData.async\n    ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]\n    : [resolvedModuleData.id, resolvedModuleData.chunks, name];\n}\nfunction requireAsyncModule(id) {\n  var promise = __turbopack_require__(id);\n  if (\"function\" !== typeof promise.then || \"fulfilled\" === promise.status)\n    return null;\n  promise.then(\n    function (value) {\n      promise.status = \"fulfilled\";\n      promise.value = value;\n    },\n    function (reason) {\n      promise.status = \"rejected\";\n      promise.reason = reason;\n    }\n  );\n  return promise;\n}\nvar instrumentedChunks = new WeakSet(),\n  loadedChunks = new WeakSet();\nfunction ignoreReject() {}\nfunction preloadModule(metadata) {\n  for (var chunks = metadata[1], promises = [], i = 0; i < chunks.length; i++) {\n    var thenable = __turbopack_load_by_url__(chunks[i]);\n    loadedChunks.has(thenable) || promises.push(thenable);\n    if (!instrumentedChunks.has(thenable)) {\n      var resolve = loadedChunks.add.bind(loadedChunks, thenable);\n      thenable.then(resolve, ignoreReject);\n      instrumentedChunks.add(thenable);\n    }\n  }\n  return 4 === metadata.length\n    ? 0 === promises.length\n      ? requireAsyncModule(metadata[0])\n      : Promise.all(promises).then(function () {\n          return requireAsyncModule(metadata[0]);\n        })\n    : 0 < promises.length\n      ? Promise.all(promises)\n      : null;\n}\nfunction requireModule(metadata) {\n  var moduleExports = __turbopack_require__(metadata[0]);\n  if (4 === metadata.length && \"function\" === typeof moduleExports.then)\n    if (\"fulfilled\" === moduleExports.status)\n      moduleExports = moduleExports.value;\n    else throw moduleExports.reason;\n  if (\"*\" === metadata[2]) return moduleExports;\n  if (\"\" === metadata[2])\n    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n  if (hasOwnProperty.call(moduleExports, metadata[2]))\n    return moduleExports[metadata[2]];\n}\nvar ReactDOMSharedInternals =\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar ASYNC_ITERATOR = Symbol.asyncIterator,\n  isArrayImpl = Array.isArray,\n  getPrototypeOf = Object.getPrototypeOf,\n  ObjectPrototype = Object.prototype,\n  knownServerReferences = new WeakMap();\nfunction serializeNumber(number) {\n  return Number.isFinite(number)\n    ? 0 === number && -Infinity === 1 / number\n      ? \"$-0\"\n      : number\n    : Infinity === number\n      ? \"$Infinity\"\n      : -Infinity === number\n        ? \"$-Infinity\"\n        : \"$NaN\";\n}\nfunction processReply(\n  root,\n  formFieldPrefix,\n  temporaryReferences,\n  resolve,\n  reject\n) {\n  function serializeTypedArray(tag, typedArray) {\n    typedArray = new Blob([\n      new Uint8Array(\n        typedArray.buffer,\n        typedArray.byteOffset,\n        typedArray.byteLength\n      )\n    ]);\n    var blobId = nextPartId++;\n    null === formData && (formData = new FormData());\n    formData.append(formFieldPrefix + blobId, typedArray);\n    return \"$\" + tag + blobId.toString(16);\n  }\n  function serializeBinaryReader(reader) {\n    function progress(entry) {\n      entry.done\n        ? ((entry = nextPartId++),\n          data.append(formFieldPrefix + entry, new Blob(buffer)),\n          data.append(\n            formFieldPrefix + streamId,\n            '\"$o' + entry.toString(16) + '\"'\n          ),\n          data.append(formFieldPrefix + streamId, \"C\"),\n          pendingParts--,\n          0 === pendingParts && resolve(data))\n        : (buffer.push(entry.value),\n          reader.read(new Uint8Array(1024)).then(progress, reject));\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++,\n      buffer = [];\n    reader.read(new Uint8Array(1024)).then(progress, reject);\n    return \"$r\" + streamId.toString(16);\n  }\n  function serializeReader(reader) {\n    function progress(entry) {\n      if (entry.done)\n        data.append(formFieldPrefix + streamId, \"C\"),\n          pendingParts--,\n          0 === pendingParts && resolve(data);\n      else\n        try {\n          var partJSON = JSON.stringify(entry.value, resolveToJSON);\n          data.append(formFieldPrefix + streamId, partJSON);\n          reader.read().then(progress, reject);\n        } catch (x) {\n          reject(x);\n        }\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++;\n    reader.read().then(progress, reject);\n    return \"$R\" + streamId.toString(16);\n  }\n  function serializeReadableStream(stream) {\n    try {\n      var binaryReader = stream.getReader({ mode: \"byob\" });\n    } catch (x) {\n      return serializeReader(stream.getReader());\n    }\n    return serializeBinaryReader(binaryReader);\n  }\n  function serializeAsyncIterable(iterable, iterator) {\n    function progress(entry) {\n      if (entry.done) {\n        if (void 0 === entry.value)\n          data.append(formFieldPrefix + streamId, \"C\");\n        else\n          try {\n            var partJSON = JSON.stringify(entry.value, resolveToJSON);\n            data.append(formFieldPrefix + streamId, \"C\" + partJSON);\n          } catch (x) {\n            reject(x);\n            return;\n          }\n        pendingParts--;\n        0 === pendingParts && resolve(data);\n      } else\n        try {\n          var partJSON$21 = JSON.stringify(entry.value, resolveToJSON);\n          data.append(formFieldPrefix + streamId, partJSON$21);\n          iterator.next().then(progress, reject);\n        } catch (x$22) {\n          reject(x$22);\n        }\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++;\n    iterable = iterable === iterator;\n    iterator.next().then(progress, reject);\n    return \"$\" + (iterable ? \"x\" : \"X\") + streamId.toString(16);\n  }\n  function resolveToJSON(key, value) {\n    if (null === value) return null;\n    if (\"object\" === typeof value) {\n      switch (value.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          if (void 0 !== temporaryReferences && -1 === key.indexOf(\":\")) {\n            var parentReference = writtenObjects.get(this);\n            if (void 0 !== parentReference)\n              return (\n                temporaryReferences.set(parentReference + \":\" + key, value),\n                \"$T\"\n              );\n          }\n          throw Error(\n            \"React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.\"\n          );\n        case REACT_LAZY_TYPE:\n          parentReference = value._payload;\n          var init = value._init;\n          null === formData && (formData = new FormData());\n          pendingParts++;\n          try {\n            var resolvedModel = init(parentReference),\n              lazyId = nextPartId++,\n              partJSON = serializeModel(resolvedModel, lazyId);\n            formData.append(formFieldPrefix + lazyId, partJSON);\n            return \"$\" + lazyId.toString(16);\n          } catch (x) {\n            if (\n              \"object\" === typeof x &&\n              null !== x &&\n              \"function\" === typeof x.then\n            ) {\n              pendingParts++;\n              var lazyId$23 = nextPartId++;\n              parentReference = function () {\n                try {\n                  var partJSON$24 = serializeModel(value, lazyId$23),\n                    data$25 = formData;\n                  data$25.append(formFieldPrefix + lazyId$23, partJSON$24);\n                  pendingParts--;\n                  0 === pendingParts && resolve(data$25);\n                } catch (reason) {\n                  reject(reason);\n                }\n              };\n              x.then(parentReference, parentReference);\n              return \"$\" + lazyId$23.toString(16);\n            }\n            reject(x);\n            return null;\n          } finally {\n            pendingParts--;\n          }\n      }\n      parentReference = writtenObjects.get(value);\n      if (\"function\" === typeof value.then) {\n        if (void 0 !== parentReference)\n          if (modelRoot === value) modelRoot = null;\n          else return parentReference;\n        null === formData && (formData = new FormData());\n        pendingParts++;\n        var promiseId = nextPartId++;\n        key = \"$@\" + promiseId.toString(16);\n        writtenObjects.set(value, key);\n        value.then(function (partValue) {\n          try {\n            var previousReference = writtenObjects.get(partValue);\n            var partJSON$27 =\n              void 0 !== previousReference\n                ? JSON.stringify(previousReference)\n                : serializeModel(partValue, promiseId);\n            partValue = formData;\n            partValue.append(formFieldPrefix + promiseId, partJSON$27);\n            pendingParts--;\n            0 === pendingParts && resolve(partValue);\n          } catch (reason) {\n            reject(reason);\n          }\n        }, reject);\n        return key;\n      }\n      if (void 0 !== parentReference)\n        if (modelRoot === value) modelRoot = null;\n        else return parentReference;\n      else\n        -1 === key.indexOf(\":\") &&\n          ((parentReference = writtenObjects.get(this)),\n          void 0 !== parentReference &&\n            ((key = parentReference + \":\" + key),\n            writtenObjects.set(value, key),\n            void 0 !== temporaryReferences &&\n              temporaryReferences.set(key, value)));\n      if (isArrayImpl(value)) return value;\n      if (value instanceof FormData) {\n        null === formData && (formData = new FormData());\n        var data$31 = formData;\n        key = nextPartId++;\n        var prefix = formFieldPrefix + key + \"_\";\n        value.forEach(function (originalValue, originalKey) {\n          data$31.append(prefix + originalKey, originalValue);\n        });\n        return \"$K\" + key.toString(16);\n      }\n      if (value instanceof Map)\n        return (\n          (key = nextPartId++),\n          (parentReference = serializeModel(Array.from(value), key)),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + key, parentReference),\n          \"$Q\" + key.toString(16)\n        );\n      if (value instanceof Set)\n        return (\n          (key = nextPartId++),\n          (parentReference = serializeModel(Array.from(value), key)),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + key, parentReference),\n          \"$W\" + key.toString(16)\n        );\n      if (value instanceof ArrayBuffer)\n        return (\n          (key = new Blob([value])),\n          (parentReference = nextPartId++),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + parentReference, key),\n          \"$A\" + parentReference.toString(16)\n        );\n      if (value instanceof Int8Array) return serializeTypedArray(\"O\", value);\n      if (value instanceof Uint8Array) return serializeTypedArray(\"o\", value);\n      if (value instanceof Uint8ClampedArray)\n        return serializeTypedArray(\"U\", value);\n      if (value instanceof Int16Array) return serializeTypedArray(\"S\", value);\n      if (value instanceof Uint16Array) return serializeTypedArray(\"s\", value);\n      if (value instanceof Int32Array) return serializeTypedArray(\"L\", value);\n      if (value instanceof Uint32Array) return serializeTypedArray(\"l\", value);\n      if (value instanceof Float32Array) return serializeTypedArray(\"G\", value);\n      if (value instanceof Float64Array) return serializeTypedArray(\"g\", value);\n      if (value instanceof BigInt64Array)\n        return serializeTypedArray(\"M\", value);\n      if (value instanceof BigUint64Array)\n        return serializeTypedArray(\"m\", value);\n      if (value instanceof DataView) return serializeTypedArray(\"V\", value);\n      if (\"function\" === typeof Blob && value instanceof Blob)\n        return (\n          null === formData && (formData = new FormData()),\n          (key = nextPartId++),\n          formData.append(formFieldPrefix + key, value),\n          \"$B\" + key.toString(16)\n        );\n      if ((key = getIteratorFn(value)))\n        return (\n          (parentReference = key.call(value)),\n          parentReference === value\n            ? ((key = nextPartId++),\n              (parentReference = serializeModel(\n                Array.from(parentReference),\n                key\n              )),\n              null === formData && (formData = new FormData()),\n              formData.append(formFieldPrefix + key, parentReference),\n              \"$i\" + key.toString(16))\n            : Array.from(parentReference)\n        );\n      if (\n        \"function\" === typeof ReadableStream &&\n        value instanceof ReadableStream\n      )\n        return serializeReadableStream(value);\n      key = value[ASYNC_ITERATOR];\n      if (\"function\" === typeof key)\n        return serializeAsyncIterable(value, key.call(value));\n      key = getPrototypeOf(value);\n      if (\n        key !== ObjectPrototype &&\n        (null === key || null !== getPrototypeOf(key))\n      ) {\n        if (void 0 === temporaryReferences)\n          throw Error(\n            \"Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.\"\n          );\n        return \"$T\";\n      }\n      return value;\n    }\n    if (\"string\" === typeof value) {\n      if (\"Z\" === value[value.length - 1] && this[key] instanceof Date)\n        return \"$D\" + value;\n      key = \"$\" === value[0] ? \"$\" + value : value;\n      return key;\n    }\n    if (\"boolean\" === typeof value) return value;\n    if (\"number\" === typeof value) return serializeNumber(value);\n    if (\"undefined\" === typeof value) return \"$undefined\";\n    if (\"function\" === typeof value) {\n      parentReference = knownServerReferences.get(value);\n      if (void 0 !== parentReference)\n        return (\n          (key = JSON.stringify(\n            { id: parentReference.id, bound: parentReference.bound },\n            resolveToJSON\n          )),\n          null === formData && (formData = new FormData()),\n          (parentReference = nextPartId++),\n          formData.set(formFieldPrefix + parentReference, key),\n          \"$h\" + parentReference.toString(16)\n        );\n      if (\n        void 0 !== temporaryReferences &&\n        -1 === key.indexOf(\":\") &&\n        ((parentReference = writtenObjects.get(this)),\n        void 0 !== parentReference)\n      )\n        return (\n          temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n        );\n      throw Error(\n        \"Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.\"\n      );\n    }\n    if (\"symbol\" === typeof value) {\n      if (\n        void 0 !== temporaryReferences &&\n        -1 === key.indexOf(\":\") &&\n        ((parentReference = writtenObjects.get(this)),\n        void 0 !== parentReference)\n      )\n        return (\n          temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n        );\n      throw Error(\n        \"Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.\"\n      );\n    }\n    if (\"bigint\" === typeof value) return \"$n\" + value.toString(10);\n    throw Error(\n      \"Type \" +\n        typeof value +\n        \" is not supported as an argument to a Server Function.\"\n    );\n  }\n  function serializeModel(model, id) {\n    \"object\" === typeof model &&\n      null !== model &&\n      ((id = \"$\" + id.toString(16)),\n      writtenObjects.set(model, id),\n      void 0 !== temporaryReferences && temporaryReferences.set(id, model));\n    modelRoot = model;\n    return JSON.stringify(model, resolveToJSON);\n  }\n  var nextPartId = 1,\n    pendingParts = 0,\n    formData = null,\n    writtenObjects = new WeakMap(),\n    modelRoot = root,\n    json = serializeModel(root, 0);\n  null === formData\n    ? resolve(json)\n    : (formData.set(formFieldPrefix + \"0\", json),\n      0 === pendingParts && resolve(formData));\n  return function () {\n    0 < pendingParts &&\n      ((pendingParts = 0),\n      null === formData ? resolve(json) : resolve(formData));\n  };\n}\nfunction registerBoundServerReference(reference, id, bound) {\n  knownServerReferences.has(reference) ||\n    knownServerReferences.set(reference, {\n      id: id,\n      originalBind: reference.bind,\n      bound: bound\n    });\n}\nfunction createBoundServerReference(metaData, callServer) {\n  function action() {\n    var args = Array.prototype.slice.call(arguments);\n    return bound\n      ? \"fulfilled\" === bound.status\n        ? callServer(id, bound.value.concat(args))\n        : Promise.resolve(bound).then(function (boundArgs) {\n            return callServer(id, boundArgs.concat(args));\n          })\n      : callServer(id, args);\n  }\n  var id = metaData.id,\n    bound = metaData.bound;\n  registerBoundServerReference(action, id, bound);\n  return action;\n}\nfunction ReactPromise(status, value, reason) {\n  this.status = status;\n  this.value = value;\n  this.reason = reason;\n}\nReactPromise.prototype = Object.create(Promise.prototype);\nReactPromise.prototype.then = function (resolve, reject) {\n  switch (this.status) {\n    case \"resolved_model\":\n      initializeModelChunk(this);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(this);\n  }\n  switch (this.status) {\n    case \"fulfilled\":\n      \"function\" === typeof resolve && resolve(this.value);\n      break;\n    case \"pending\":\n    case \"blocked\":\n      \"function\" === typeof resolve &&\n        (null === this.value && (this.value = []), this.value.push(resolve));\n      \"function\" === typeof reject &&\n        (null === this.reason && (this.reason = []), this.reason.push(reject));\n      break;\n    case \"halted\":\n      break;\n    default:\n      \"function\" === typeof reject && reject(this.reason);\n  }\n};\nfunction readChunk(chunk) {\n  switch (chunk.status) {\n    case \"resolved_model\":\n      initializeModelChunk(chunk);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(chunk);\n  }\n  switch (chunk.status) {\n    case \"fulfilled\":\n      return chunk.value;\n    case \"pending\":\n    case \"blocked\":\n    case \"halted\":\n      throw chunk;\n    default:\n      throw chunk.reason;\n  }\n}\nfunction wakeChunk(response, listeners, value, chunk) {\n  for (var i = 0; i < listeners.length; i++) {\n    var listener = listeners[i];\n    \"function\" === typeof listener\n      ? listener(value)\n      : fulfillReference(response, listener, value, chunk);\n  }\n}\nfunction rejectChunk(response, listeners, error) {\n  for (var i = 0; i < listeners.length; i++) {\n    var listener = listeners[i];\n    \"function\" === typeof listener\n      ? listener(error)\n      : rejectReference(response, listener.handler, error);\n  }\n}\nfunction resolveBlockedCycle(resolvedChunk, reference) {\n  var referencedChunk = reference.handler.chunk;\n  if (null === referencedChunk) return null;\n  if (referencedChunk === resolvedChunk) return reference.handler;\n  reference = referencedChunk.value;\n  if (null !== reference)\n    for (\n      referencedChunk = 0;\n      referencedChunk < reference.length;\n      referencedChunk++\n    ) {\n      var listener = reference[referencedChunk];\n      if (\n        \"function\" !== typeof listener &&\n        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n        null !== listener)\n      )\n        return listener;\n    }\n  return null;\n}\nfunction wakeChunkIfInitialized(\n  response,\n  chunk,\n  resolveListeners,\n  rejectListeners\n) {\n  switch (chunk.status) {\n    case \"fulfilled\":\n      wakeChunk(response, resolveListeners, chunk.value, chunk);\n      break;\n    case \"blocked\":\n      for (var i = 0; i < resolveListeners.length; i++) {\n        var listener = resolveListeners[i];\n        if (\"function\" !== typeof listener) {\n          var cyclicHandler = resolveBlockedCycle(chunk, listener);\n          if (null !== cyclicHandler)\n            switch (\n              (fulfillReference(response, listener, cyclicHandler.value, chunk),\n              resolveListeners.splice(i, 1),\n              i--,\n              null !== rejectListeners &&\n                ((listener = rejectListeners.indexOf(listener)),\n                -1 !== listener && rejectListeners.splice(listener, 1)),\n              chunk.status)\n            ) {\n              case \"fulfilled\":\n                wakeChunk(response, resolveListeners, chunk.value, chunk);\n                return;\n              case \"rejected\":\n                null !== rejectListeners &&\n                  rejectChunk(response, rejectListeners, chunk.reason);\n                return;\n            }\n        }\n      }\n    case \"pending\":\n      if (chunk.value)\n        for (response = 0; response < resolveListeners.length; response++)\n          chunk.value.push(resolveListeners[response]);\n      else chunk.value = resolveListeners;\n      if (chunk.reason) {\n        if (rejectListeners)\n          for (\n            resolveListeners = 0;\n            resolveListeners < rejectListeners.length;\n            resolveListeners++\n          )\n            chunk.reason.push(rejectListeners[resolveListeners]);\n      } else chunk.reason = rejectListeners;\n      break;\n    case \"rejected\":\n      rejectListeners && rejectChunk(response, rejectListeners, chunk.reason);\n  }\n}\nfunction triggerErrorOnChunk(response, chunk, error) {\n  if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n    chunk.reason.error(error);\n  else {\n    var listeners = chunk.reason;\n    chunk.status = \"rejected\";\n    chunk.reason = error;\n    null !== listeners && rejectChunk(response, listeners, error);\n  }\n}\nfunction createResolvedIteratorResultChunk(response, value, done) {\n  return new ReactPromise(\n    \"resolved_model\",\n    (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n    response\n  );\n}\nfunction resolveIteratorResultChunk(response, chunk, value, done) {\n  resolveModelChunk(\n    response,\n    chunk,\n    (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\"\n  );\n}\nfunction resolveModelChunk(response, chunk, value) {\n  if (\"pending\" !== chunk.status) chunk.reason.enqueueModel(value);\n  else {\n    var resolveListeners = chunk.value,\n      rejectListeners = chunk.reason;\n    chunk.status = \"resolved_model\";\n    chunk.value = value;\n    chunk.reason = response;\n    null !== resolveListeners &&\n      (initializeModelChunk(chunk),\n      wakeChunkIfInitialized(\n        response,\n        chunk,\n        resolveListeners,\n        rejectListeners\n      ));\n  }\n}\nfunction resolveModuleChunk(response, chunk, value) {\n  if (\"pending\" === chunk.status || \"blocked\" === chunk.status) {\n    var resolveListeners = chunk.value,\n      rejectListeners = chunk.reason;\n    chunk.status = \"resolved_module\";\n    chunk.value = value;\n    chunk.reason = null;\n    null !== resolveListeners &&\n      (initializeModuleChunk(chunk),\n      wakeChunkIfInitialized(\n        response,\n        chunk,\n        resolveListeners,\n        rejectListeners\n      ));\n  }\n}\nvar initializingHandler = null;\nfunction initializeModelChunk(chunk) {\n  var prevHandler = initializingHandler;\n  initializingHandler = null;\n  var resolvedModel = chunk.value,\n    response = chunk.reason;\n  chunk.status = \"blocked\";\n  chunk.value = null;\n  chunk.reason = null;\n  try {\n    var value = JSON.parse(resolvedModel, response._fromJSON),\n      resolveListeners = chunk.value;\n    if (null !== resolveListeners)\n      for (\n        chunk.value = null, chunk.reason = null, resolvedModel = 0;\n        resolvedModel < resolveListeners.length;\n        resolvedModel++\n      ) {\n        var listener = resolveListeners[resolvedModel];\n        \"function\" === typeof listener\n          ? listener(value)\n          : fulfillReference(response, listener, value, chunk);\n      }\n    if (null !== initializingHandler) {\n      if (initializingHandler.errored) throw initializingHandler.reason;\n      if (0 < initializingHandler.deps) {\n        initializingHandler.value = value;\n        initializingHandler.chunk = chunk;\n        return;\n      }\n    }\n    chunk.status = \"fulfilled\";\n    chunk.value = value;\n  } catch (error) {\n    (chunk.status = \"rejected\"), (chunk.reason = error);\n  } finally {\n    initializingHandler = prevHandler;\n  }\n}\nfunction initializeModuleChunk(chunk) {\n  try {\n    var value = requireModule(chunk.value);\n    chunk.status = \"fulfilled\";\n    chunk.value = value;\n  } catch (error) {\n    (chunk.status = \"rejected\"), (chunk.reason = error);\n  }\n}\nfunction reportGlobalError(weakResponse, error) {\n  weakResponse._closed = !0;\n  weakResponse._closedReason = error;\n  weakResponse._chunks.forEach(function (chunk) {\n    \"pending\" === chunk.status\n      ? triggerErrorOnChunk(weakResponse, chunk, error)\n      : \"fulfilled\" === chunk.status &&\n        null !== chunk.reason &&\n        chunk.reason.error(error);\n  });\n}\nfunction createLazyChunkWrapper(chunk) {\n  return { $$typeof: REACT_LAZY_TYPE, _payload: chunk, _init: readChunk };\n}\nfunction getChunk(response, id) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  chunk ||\n    ((chunk = response._closed\n      ? new ReactPromise(\"rejected\", null, response._closedReason)\n      : new ReactPromise(\"pending\", null, null)),\n    chunks.set(id, chunk));\n  return chunk;\n}\nfunction fulfillReference(response, reference, value) {\n  var handler = reference.handler,\n    parentObject = reference.parentObject,\n    key = reference.key,\n    map = reference.map,\n    path = reference.path;\n  try {\n    for (var i = 1; i < path.length; i++) {\n      for (\n        ;\n        \"object\" === typeof value &&\n        null !== value &&\n        value.$$typeof === REACT_LAZY_TYPE;\n\n      ) {\n        var referencedChunk = value._payload;\n        if (referencedChunk === handler.chunk) value = handler.value;\n        else {\n          switch (referencedChunk.status) {\n            case \"resolved_model\":\n              initializeModelChunk(referencedChunk);\n              break;\n            case \"resolved_module\":\n              initializeModuleChunk(referencedChunk);\n          }\n          switch (referencedChunk.status) {\n            case \"fulfilled\":\n              value = referencedChunk.value;\n              continue;\n            case \"blocked\":\n              var cyclicHandler = resolveBlockedCycle(\n                referencedChunk,\n                reference\n              );\n              if (null !== cyclicHandler) {\n                value = cyclicHandler.value;\n                continue;\n              }\n            case \"pending\":\n              path.splice(0, i - 1);\n              null === referencedChunk.value\n                ? (referencedChunk.value = [reference])\n                : referencedChunk.value.push(reference);\n              null === referencedChunk.reason\n                ? (referencedChunk.reason = [reference])\n                : referencedChunk.reason.push(reference);\n              return;\n            case \"halted\":\n              return;\n            default:\n              rejectReference(\n                response,\n                reference.handler,\n                referencedChunk.reason\n              );\n              return;\n          }\n        }\n      }\n      value = value[path[i]];\n    }\n    for (\n      ;\n      \"object\" === typeof value &&\n      null !== value &&\n      value.$$typeof === REACT_LAZY_TYPE;\n\n    ) {\n      var referencedChunk$43 = value._payload;\n      if (referencedChunk$43 === handler.chunk) value = handler.value;\n      else {\n        switch (referencedChunk$43.status) {\n          case \"resolved_model\":\n            initializeModelChunk(referencedChunk$43);\n            break;\n          case \"resolved_module\":\n            initializeModuleChunk(referencedChunk$43);\n        }\n        switch (referencedChunk$43.status) {\n          case \"fulfilled\":\n            value = referencedChunk$43.value;\n            continue;\n        }\n        break;\n      }\n    }\n    var mappedValue = map(response, value, parentObject, key);\n    parentObject[key] = mappedValue;\n    \"\" === key && null === handler.value && (handler.value = mappedValue);\n    if (\n      parentObject[0] === REACT_ELEMENT_TYPE &&\n      \"object\" === typeof handler.value &&\n      null !== handler.value &&\n      handler.value.$$typeof === REACT_ELEMENT_TYPE\n    ) {\n      var element = handler.value;\n      switch (key) {\n        case \"3\":\n          element.props = mappedValue;\n      }\n    }\n  } catch (error) {\n    rejectReference(response, reference.handler, error);\n    return;\n  }\n  handler.deps--;\n  0 === handler.deps &&\n    ((reference = handler.chunk),\n    null !== reference &&\n      \"blocked\" === reference.status &&\n      ((value = reference.value),\n      (reference.status = \"fulfilled\"),\n      (reference.value = handler.value),\n      (reference.reason = handler.reason),\n      null !== value && wakeChunk(response, value, handler.value, reference)));\n}\nfunction rejectReference(response, handler, error) {\n  handler.errored ||\n    ((handler.errored = !0),\n    (handler.value = null),\n    (handler.reason = error),\n    (handler = handler.chunk),\n    null !== handler &&\n      \"blocked\" === handler.status &&\n      triggerErrorOnChunk(response, handler, error));\n}\nfunction waitForReference(\n  referencedChunk,\n  parentObject,\n  key,\n  response,\n  map,\n  path\n) {\n  initializingHandler\n    ? ((response = initializingHandler), response.deps++)\n    : (response = initializingHandler =\n        {\n          parent: null,\n          chunk: null,\n          value: null,\n          reason: null,\n          deps: 1,\n          errored: !1\n        });\n  parentObject = {\n    handler: response,\n    parentObject: parentObject,\n    key: key,\n    map: map,\n    path: path\n  };\n  null === referencedChunk.value\n    ? (referencedChunk.value = [parentObject])\n    : referencedChunk.value.push(parentObject);\n  null === referencedChunk.reason\n    ? (referencedChunk.reason = [parentObject])\n    : referencedChunk.reason.push(parentObject);\n  return null;\n}\nfunction loadServerReference(response, metaData, parentObject, key) {\n  if (!response._serverReferenceConfig)\n    return createBoundServerReference(metaData, response._callServer);\n  var serverReference = resolveServerReference(\n      response._serverReferenceConfig,\n      metaData.id\n    ),\n    promise = preloadModule(serverReference);\n  if (promise)\n    metaData.bound && (promise = Promise.all([promise, metaData.bound]));\n  else if (metaData.bound) promise = Promise.resolve(metaData.bound);\n  else\n    return (\n      (promise = requireModule(serverReference)),\n      registerBoundServerReference(promise, metaData.id, metaData.bound),\n      promise\n    );\n  if (initializingHandler) {\n    var handler = initializingHandler;\n    handler.deps++;\n  } else\n    handler = initializingHandler = {\n      parent: null,\n      chunk: null,\n      value: null,\n      reason: null,\n      deps: 1,\n      errored: !1\n    };\n  promise.then(\n    function () {\n      var resolvedValue = requireModule(serverReference);\n      if (metaData.bound) {\n        var boundArgs = metaData.bound.value.slice(0);\n        boundArgs.unshift(null);\n        resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);\n      }\n      registerBoundServerReference(resolvedValue, metaData.id, metaData.bound);\n      parentObject[key] = resolvedValue;\n      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n      if (\n        parentObject[0] === REACT_ELEMENT_TYPE &&\n        \"object\" === typeof handler.value &&\n        null !== handler.value &&\n        handler.value.$$typeof === REACT_ELEMENT_TYPE\n      )\n        switch (((boundArgs = handler.value), key)) {\n          case \"3\":\n            boundArgs.props = resolvedValue;\n        }\n      handler.deps--;\n      0 === handler.deps &&\n        ((resolvedValue = handler.chunk),\n        null !== resolvedValue &&\n          \"blocked\" === resolvedValue.status &&\n          ((boundArgs = resolvedValue.value),\n          (resolvedValue.status = \"fulfilled\"),\n          (resolvedValue.value = handler.value),\n          (resolvedValue.reason = null),\n          null !== boundArgs &&\n            wakeChunk(response, boundArgs, handler.value, resolvedValue)));\n    },\n    function (error) {\n      if (!handler.errored) {\n        handler.errored = !0;\n        handler.value = null;\n        handler.reason = error;\n        var chunk = handler.chunk;\n        null !== chunk &&\n          \"blocked\" === chunk.status &&\n          triggerErrorOnChunk(response, chunk, error);\n      }\n    }\n  );\n  return null;\n}\nfunction getOutlinedModel(response, reference, parentObject, key, map) {\n  reference = reference.split(\":\");\n  var id = parseInt(reference[0], 16);\n  id = getChunk(response, id);\n  switch (id.status) {\n    case \"resolved_model\":\n      initializeModelChunk(id);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(id);\n  }\n  switch (id.status) {\n    case \"fulfilled\":\n      id = id.value;\n      for (var i = 1; i < reference.length; i++) {\n        for (\n          ;\n          \"object\" === typeof id &&\n          null !== id &&\n          id.$$typeof === REACT_LAZY_TYPE;\n\n        ) {\n          id = id._payload;\n          switch (id.status) {\n            case \"resolved_model\":\n              initializeModelChunk(id);\n              break;\n            case \"resolved_module\":\n              initializeModuleChunk(id);\n          }\n          switch (id.status) {\n            case \"fulfilled\":\n              id = id.value;\n              break;\n            case \"blocked\":\n            case \"pending\":\n              return waitForReference(\n                id,\n                parentObject,\n                key,\n                response,\n                map,\n                reference.slice(i - 1)\n              );\n            case \"halted\":\n              return (\n                initializingHandler\n                  ? ((response = initializingHandler), response.deps++)\n                  : (initializingHandler = {\n                      parent: null,\n                      chunk: null,\n                      value: null,\n                      reason: null,\n                      deps: 1,\n                      errored: !1\n                    }),\n                null\n              );\n            default:\n              return (\n                initializingHandler\n                  ? ((initializingHandler.errored = !0),\n                    (initializingHandler.value = null),\n                    (initializingHandler.reason = id.reason))\n                  : (initializingHandler = {\n                      parent: null,\n                      chunk: null,\n                      value: null,\n                      reason: id.reason,\n                      deps: 0,\n                      errored: !0\n                    }),\n                null\n              );\n          }\n        }\n        id = id[reference[i]];\n      }\n      for (\n        ;\n        \"object\" === typeof id &&\n        null !== id &&\n        id.$$typeof === REACT_LAZY_TYPE;\n\n      ) {\n        reference = id._payload;\n        switch (reference.status) {\n          case \"resolved_model\":\n            initializeModelChunk(reference);\n            break;\n          case \"resolved_module\":\n            initializeModuleChunk(reference);\n        }\n        switch (reference.status) {\n          case \"fulfilled\":\n            id = reference.value;\n            continue;\n        }\n        break;\n      }\n      return map(response, id, parentObject, key);\n    case \"pending\":\n    case \"blocked\":\n      return waitForReference(id, parentObject, key, response, map, reference);\n    case \"halted\":\n      return (\n        initializingHandler\n          ? ((response = initializingHandler), response.deps++)\n          : (initializingHandler = {\n              parent: null,\n              chunk: null,\n              value: null,\n              reason: null,\n              deps: 1,\n              errored: !1\n            }),\n        null\n      );\n    default:\n      return (\n        initializingHandler\n          ? ((initializingHandler.errored = !0),\n            (initializingHandler.value = null),\n            (initializingHandler.reason = id.reason))\n          : (initializingHandler = {\n              parent: null,\n              chunk: null,\n              value: null,\n              reason: id.reason,\n              deps: 0,\n              errored: !0\n            }),\n        null\n      );\n  }\n}\nfunction createMap(response, model) {\n  return new Map(model);\n}\nfunction createSet(response, model) {\n  return new Set(model);\n}\nfunction createBlob(response, model) {\n  return new Blob(model.slice(1), { type: model[0] });\n}\nfunction createFormData(response, model) {\n  response = new FormData();\n  for (var i = 0; i < model.length; i++)\n    response.append(model[i][0], model[i][1]);\n  return response;\n}\nfunction extractIterator(response, model) {\n  return model[Symbol.iterator]();\n}\nfunction createModel(response, model) {\n  return model;\n}\nfunction parseModelString(response, parentObject, key, value) {\n  if (\"$\" === value[0]) {\n    if (\"$\" === value)\n      return (\n        null !== initializingHandler &&\n          \"0\" === key &&\n          (initializingHandler = {\n            parent: initializingHandler,\n            chunk: null,\n            value: null,\n            reason: null,\n            deps: 0,\n            errored: !1\n          }),\n        REACT_ELEMENT_TYPE\n      );\n    switch (value[1]) {\n      case \"$\":\n        return value.slice(1);\n      case \"L\":\n        return (\n          (parentObject = parseInt(value.slice(2), 16)),\n          (response = getChunk(response, parentObject)),\n          createLazyChunkWrapper(response)\n        );\n      case \"@\":\n        return (\n          (parentObject = parseInt(value.slice(2), 16)),\n          getChunk(response, parentObject)\n        );\n      case \"S\":\n        return Symbol.for(value.slice(2));\n      case \"h\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(\n            response,\n            value,\n            parentObject,\n            key,\n            loadServerReference\n          )\n        );\n      case \"T\":\n        parentObject = \"$\" + value.slice(2);\n        response = response._tempRefs;\n        if (null == response)\n          throw Error(\n            \"Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.\"\n          );\n        return response.get(parentObject);\n      case \"Q\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createMap)\n        );\n      case \"W\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createSet)\n        );\n      case \"B\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createBlob)\n        );\n      case \"K\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createFormData)\n        );\n      case \"Z\":\n        return resolveErrorProd();\n      case \"i\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, extractIterator)\n        );\n      case \"I\":\n        return Infinity;\n      case \"-\":\n        return \"$-0\" === value ? -0 : -Infinity;\n      case \"N\":\n        return NaN;\n      case \"u\":\n        return;\n      case \"D\":\n        return new Date(Date.parse(value.slice(2)));\n      case \"n\":\n        return BigInt(value.slice(2));\n      default:\n        return (\n          (value = value.slice(1)),\n          getOutlinedModel(response, value, parentObject, key, createModel)\n        );\n    }\n  }\n  return value;\n}\nfunction missingCall() {\n  throw Error(\n    'Trying to call a function from \"use server\" but the callServer option was not implemented in your router runtime.'\n  );\n}\nfunction ResponseInstance(\n  bundlerConfig,\n  serverReferenceConfig,\n  moduleLoading,\n  callServer,\n  encodeFormAction,\n  nonce,\n  temporaryReferences\n) {\n  var chunks = new Map();\n  this._bundlerConfig = bundlerConfig;\n  this._serverReferenceConfig = serverReferenceConfig;\n  this._moduleLoading = moduleLoading;\n  this._callServer = void 0 !== callServer ? callServer : missingCall;\n  this._encodeFormAction = encodeFormAction;\n  this._nonce = nonce;\n  this._chunks = chunks;\n  this._stringDecoder = new TextDecoder();\n  this._fromJSON = null;\n  this._closed = !1;\n  this._closedReason = null;\n  this._tempRefs = temporaryReferences;\n  this._fromJSON = createFromJSONCallback(this);\n}\nfunction resolveBuffer(response, id, buffer) {\n  response = response._chunks;\n  var chunk = response.get(id);\n  chunk && \"pending\" !== chunk.status\n    ? chunk.reason.enqueueValue(buffer)\n    : ((buffer = new ReactPromise(\"fulfilled\", buffer, null)),\n      response.set(id, buffer));\n}\nfunction resolveModule(response, id, model) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  model = JSON.parse(model, response._fromJSON);\n  var clientReference = resolveClientReference(response._bundlerConfig, model);\n  if ((model = preloadModule(clientReference))) {\n    if (chunk) {\n      var blockedChunk = chunk;\n      blockedChunk.status = \"blocked\";\n    } else\n      (blockedChunk = new ReactPromise(\"blocked\", null, null)),\n        chunks.set(id, blockedChunk);\n    model.then(\n      function () {\n        return resolveModuleChunk(response, blockedChunk, clientReference);\n      },\n      function (error) {\n        return triggerErrorOnChunk(response, blockedChunk, error);\n      }\n    );\n  } else\n    chunk\n      ? resolveModuleChunk(response, chunk, clientReference)\n      : ((chunk = new ReactPromise(\"resolved_module\", clientReference, null)),\n        chunks.set(id, chunk));\n}\nfunction resolveStream(response, id, stream, controller) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  chunk\n    ? \"pending\" === chunk.status &&\n      ((id = chunk.value),\n      (chunk.status = \"fulfilled\"),\n      (chunk.value = stream),\n      (chunk.reason = controller),\n      null !== id && wakeChunk(response, id, chunk.value, chunk))\n    : ((response = new ReactPromise(\"fulfilled\", stream, controller)),\n      chunks.set(id, response));\n}\nfunction startReadableStream(response, id, type) {\n  var controller = null,\n    closed = !1;\n  type = new ReadableStream({\n    type: type,\n    start: function (c) {\n      controller = c;\n    }\n  });\n  var previousBlockedChunk = null;\n  resolveStream(response, id, type, {\n    enqueueValue: function (value) {\n      null === previousBlockedChunk\n        ? controller.enqueue(value)\n        : previousBlockedChunk.then(function () {\n            controller.enqueue(value);\n          });\n    },\n    enqueueModel: function (json) {\n      if (null === previousBlockedChunk) {\n        var chunk = new ReactPromise(\"resolved_model\", json, response);\n        initializeModelChunk(chunk);\n        \"fulfilled\" === chunk.status\n          ? controller.enqueue(chunk.value)\n          : (chunk.then(\n              function (v) {\n                return controller.enqueue(v);\n              },\n              function (e) {\n                return controller.error(e);\n              }\n            ),\n            (previousBlockedChunk = chunk));\n      } else {\n        chunk = previousBlockedChunk;\n        var chunk$54 = new ReactPromise(\"pending\", null, null);\n        chunk$54.then(\n          function (v) {\n            return controller.enqueue(v);\n          },\n          function (e) {\n            return controller.error(e);\n          }\n        );\n        previousBlockedChunk = chunk$54;\n        chunk.then(function () {\n          previousBlockedChunk === chunk$54 && (previousBlockedChunk = null);\n          resolveModelChunk(response, chunk$54, json);\n        });\n      }\n    },\n    close: function () {\n      if (!closed)\n        if (((closed = !0), null === previousBlockedChunk)) controller.close();\n        else {\n          var blockedChunk = previousBlockedChunk;\n          previousBlockedChunk = null;\n          blockedChunk.then(function () {\n            return controller.close();\n          });\n        }\n    },\n    error: function (error) {\n      if (!closed)\n        if (((closed = !0), null === previousBlockedChunk))\n          controller.error(error);\n        else {\n          var blockedChunk = previousBlockedChunk;\n          previousBlockedChunk = null;\n          blockedChunk.then(function () {\n            return controller.error(error);\n          });\n        }\n    }\n  });\n}\nfunction asyncIterator() {\n  return this;\n}\nfunction createIterator(next) {\n  next = { next: next };\n  next[ASYNC_ITERATOR] = asyncIterator;\n  return next;\n}\nfunction startAsyncIterable(response, id, iterator) {\n  var buffer = [],\n    closed = !1,\n    nextWriteIndex = 0,\n    iterable = {};\n  iterable[ASYNC_ITERATOR] = function () {\n    var nextReadIndex = 0;\n    return createIterator(function (arg) {\n      if (void 0 !== arg)\n        throw Error(\n          \"Values cannot be passed to next() of AsyncIterables passed to Client Components.\"\n        );\n      if (nextReadIndex === buffer.length) {\n        if (closed)\n          return new ReactPromise(\n            \"fulfilled\",\n            { done: !0, value: void 0 },\n            null\n          );\n        buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n      }\n      return buffer[nextReadIndex++];\n    });\n  };\n  resolveStream(\n    response,\n    id,\n    iterator ? iterable[ASYNC_ITERATOR]() : iterable,\n    {\n      enqueueValue: function (value) {\n        if (nextWriteIndex === buffer.length)\n          buffer[nextWriteIndex] = new ReactPromise(\n            \"fulfilled\",\n            { done: !1, value: value },\n            null\n          );\n        else {\n          var chunk = buffer[nextWriteIndex],\n            resolveListeners = chunk.value,\n            rejectListeners = chunk.reason;\n          chunk.status = \"fulfilled\";\n          chunk.value = { done: !1, value: value };\n          chunk.reason = null;\n          null !== resolveListeners &&\n            wakeChunkIfInitialized(\n              response,\n              chunk,\n              resolveListeners,\n              rejectListeners\n            );\n        }\n        nextWriteIndex++;\n      },\n      enqueueModel: function (value) {\n        nextWriteIndex === buffer.length\n          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n              response,\n              value,\n              !1\n            ))\n          : resolveIteratorResultChunk(\n              response,\n              buffer[nextWriteIndex],\n              value,\n              !1\n            );\n        nextWriteIndex++;\n      },\n      close: function (value) {\n        if (!closed)\n          for (\n            closed = !0,\n              nextWriteIndex === buffer.length\n                ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n                    response,\n                    value,\n                    !0\n                  ))\n                : resolveIteratorResultChunk(\n                    response,\n                    buffer[nextWriteIndex],\n                    value,\n                    !0\n                  ),\n              nextWriteIndex++;\n            nextWriteIndex < buffer.length;\n\n          )\n            resolveIteratorResultChunk(\n              response,\n              buffer[nextWriteIndex++],\n              '\"$undefined\"',\n              !0\n            );\n      },\n      error: function (error) {\n        if (!closed)\n          for (\n            closed = !0,\n              nextWriteIndex === buffer.length &&\n                (buffer[nextWriteIndex] = new ReactPromise(\n                  \"pending\",\n                  null,\n                  null\n                ));\n            nextWriteIndex < buffer.length;\n\n          )\n            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n      }\n    }\n  );\n}\nfunction resolveErrorProd() {\n  var error = Error(\n    \"An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.\"\n  );\n  error.stack = \"Error: \" + error.message;\n  return error;\n}\nfunction mergeBuffer(buffer, lastChunk) {\n  for (var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)\n    byteLength += buffer[i].byteLength;\n  byteLength = new Uint8Array(byteLength);\n  for (var i$55 = (i = 0); i$55 < l; i$55++) {\n    var chunk = buffer[i$55];\n    byteLength.set(chunk, i);\n    i += chunk.byteLength;\n  }\n  byteLength.set(lastChunk, i);\n  return byteLength;\n}\nfunction resolveTypedArray(\n  response,\n  id,\n  buffer,\n  lastChunk,\n  constructor,\n  bytesPerElement\n) {\n  buffer =\n    0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement\n      ? lastChunk\n      : mergeBuffer(buffer, lastChunk);\n  constructor = new constructor(\n    buffer.buffer,\n    buffer.byteOffset,\n    buffer.byteLength / bytesPerElement\n  );\n  resolveBuffer(response, id, constructor);\n}\nfunction processFullBinaryRow(response, streamState, id, tag, buffer, chunk) {\n  switch (tag) {\n    case 65:\n      resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);\n      return;\n    case 79:\n      resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);\n      return;\n    case 111:\n      resolveBuffer(\n        response,\n        id,\n        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)\n      );\n      return;\n    case 85:\n      resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);\n      return;\n    case 83:\n      resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);\n      return;\n    case 115:\n      resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);\n      return;\n    case 76:\n      resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);\n      return;\n    case 108:\n      resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);\n      return;\n    case 71:\n      resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);\n      return;\n    case 103:\n      resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);\n      return;\n    case 77:\n      resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);\n      return;\n    case 109:\n      resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);\n      return;\n    case 86:\n      resolveTypedArray(response, id, buffer, chunk, DataView, 1);\n      return;\n  }\n  streamState = response._stringDecoder;\n  for (var row = \"\", i = 0; i < buffer.length; i++)\n    row += streamState.decode(buffer[i], decoderOptions);\n  buffer = row += streamState.decode(chunk);\n  switch (tag) {\n    case 73:\n      resolveModule(response, id, buffer);\n      break;\n    case 72:\n      id = buffer[0];\n      buffer = buffer.slice(1);\n      response = JSON.parse(buffer, response._fromJSON);\n      buffer = ReactDOMSharedInternals.d;\n      switch (id) {\n        case \"D\":\n          buffer.D(response);\n          break;\n        case \"C\":\n          \"string\" === typeof response\n            ? buffer.C(response)\n            : buffer.C(response[0], response[1]);\n          break;\n        case \"L\":\n          id = response[0];\n          tag = response[1];\n          3 === response.length\n            ? buffer.L(id, tag, response[2])\n            : buffer.L(id, tag);\n          break;\n        case \"m\":\n          \"string\" === typeof response\n            ? buffer.m(response)\n            : buffer.m(response[0], response[1]);\n          break;\n        case \"X\":\n          \"string\" === typeof response\n            ? buffer.X(response)\n            : buffer.X(response[0], response[1]);\n          break;\n        case \"S\":\n          \"string\" === typeof response\n            ? buffer.S(response)\n            : buffer.S(\n                response[0],\n                0 === response[1] ? void 0 : response[1],\n                3 === response.length ? response[2] : void 0\n              );\n          break;\n        case \"M\":\n          \"string\" === typeof response\n            ? buffer.M(response)\n            : buffer.M(response[0], response[1]);\n      }\n      break;\n    case 69:\n      tag = response._chunks;\n      chunk = tag.get(id);\n      buffer = JSON.parse(buffer);\n      streamState = resolveErrorProd();\n      streamState.digest = buffer.digest;\n      chunk\n        ? triggerErrorOnChunk(response, chunk, streamState)\n        : ((response = new ReactPromise(\"rejected\", null, streamState)),\n          tag.set(id, response));\n      break;\n    case 84:\n      response = response._chunks;\n      (tag = response.get(id)) && \"pending\" !== tag.status\n        ? tag.reason.enqueueValue(buffer)\n        : ((buffer = new ReactPromise(\"fulfilled\", buffer, null)),\n          response.set(id, buffer));\n      break;\n    case 78:\n    case 68:\n    case 74:\n    case 87:\n      throw Error(\n        \"Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.\"\n      );\n    case 82:\n      startReadableStream(response, id, void 0);\n      break;\n    case 114:\n      startReadableStream(response, id, \"bytes\");\n      break;\n    case 88:\n      startAsyncIterable(response, id, !1);\n      break;\n    case 120:\n      startAsyncIterable(response, id, !0);\n      break;\n    case 67:\n      (id = response._chunks.get(id)) &&\n        \"fulfilled\" === id.status &&\n        id.reason.close(\"\" === buffer ? '\"$undefined\"' : buffer);\n      break;\n    default:\n      (tag = response._chunks),\n        (chunk = tag.get(id))\n          ? resolveModelChunk(response, chunk, buffer)\n          : ((response = new ReactPromise(\"resolved_model\", buffer, response)),\n            tag.set(id, response));\n  }\n}\nfunction createFromJSONCallback(response) {\n  return function (key, value) {\n    if (\"string\" === typeof value)\n      return parseModelString(response, this, key, value);\n    if (\"object\" === typeof value && null !== value) {\n      if (value[0] === REACT_ELEMENT_TYPE) {\n        if (\n          ((key = {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type: value[1],\n            key: value[2],\n            ref: null,\n            props: value[3]\n          }),\n          null !== initializingHandler)\n        )\n          if (\n            ((value = initializingHandler),\n            (initializingHandler = value.parent),\n            value.errored)\n          )\n            (key = new ReactPromise(\"rejected\", null, value.reason)),\n              (key = createLazyChunkWrapper(key));\n          else if (0 < value.deps) {\n            var blockedChunk = new ReactPromise(\"blocked\", null, null);\n            value.value = key;\n            value.chunk = blockedChunk;\n            key = createLazyChunkWrapper(blockedChunk);\n          }\n      } else key = value;\n      return key;\n    }\n    return value;\n  };\n}\nfunction close(weakResponse) {\n  reportGlobalError(weakResponse, Error(\"Connection closed.\"));\n}\nfunction createResponseFromOptions(options) {\n  return new ResponseInstance(\n    null,\n    null,\n    null,\n    options && options.callServer ? options.callServer : void 0,\n    void 0,\n    void 0,\n    options && options.temporaryReferences\n      ? options.temporaryReferences\n      : void 0\n  );\n}\nfunction startReadingFromStream(response, stream, onDone) {\n  function progress(_ref2) {\n    var value = _ref2.value;\n    if (_ref2.done) return onDone();\n    var i = 0,\n      rowState = streamState._rowState;\n    _ref2 = streamState._rowID;\n    for (\n      var rowTag = streamState._rowTag,\n        rowLength = streamState._rowLength,\n        buffer = streamState._buffer,\n        chunkLength = value.length;\n      i < chunkLength;\n\n    ) {\n      var lastIdx = -1;\n      switch (rowState) {\n        case 0:\n          lastIdx = value[i++];\n          58 === lastIdx\n            ? (rowState = 1)\n            : (_ref2 =\n                (_ref2 << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n          continue;\n        case 1:\n          rowState = value[i];\n          84 === rowState ||\n          65 === rowState ||\n          79 === rowState ||\n          111 === rowState ||\n          98 === rowState ||\n          85 === rowState ||\n          83 === rowState ||\n          115 === rowState ||\n          76 === rowState ||\n          108 === rowState ||\n          71 === rowState ||\n          103 === rowState ||\n          77 === rowState ||\n          109 === rowState ||\n          86 === rowState\n            ? ((rowTag = rowState), (rowState = 2), i++)\n            : (64 < rowState && 91 > rowState) ||\n                35 === rowState ||\n                114 === rowState ||\n                120 === rowState\n              ? ((rowTag = rowState), (rowState = 3), i++)\n              : ((rowTag = 0), (rowState = 3));\n          continue;\n        case 2:\n          lastIdx = value[i++];\n          44 === lastIdx\n            ? (rowState = 4)\n            : (rowLength =\n                (rowLength << 4) |\n                (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n          continue;\n        case 3:\n          lastIdx = value.indexOf(10, i);\n          break;\n        case 4:\n          (lastIdx = i + rowLength), lastIdx > value.length && (lastIdx = -1);\n      }\n      var offset = value.byteOffset + i;\n      if (-1 < lastIdx)\n        (rowLength = new Uint8Array(value.buffer, offset, lastIdx - i)),\n          98 === rowTag\n            ? resolveBuffer(\n                response,\n                _ref2,\n                lastIdx === chunkLength ? rowLength : rowLength.slice()\n              )\n            : processFullBinaryRow(\n                response,\n                streamState,\n                _ref2,\n                rowTag,\n                buffer,\n                rowLength\n              ),\n          (i = lastIdx),\n          3 === rowState && i++,\n          (rowLength = _ref2 = rowTag = rowState = 0),\n          (buffer.length = 0);\n      else {\n        value = new Uint8Array(value.buffer, offset, value.byteLength - i);\n        98 === rowTag\n          ? ((rowLength -= value.byteLength),\n            resolveBuffer(response, _ref2, value))\n          : (buffer.push(value), (rowLength -= value.byteLength));\n        break;\n      }\n    }\n    streamState._rowState = rowState;\n    streamState._rowID = _ref2;\n    streamState._rowTag = rowTag;\n    streamState._rowLength = rowLength;\n    return reader.read().then(progress).catch(error);\n  }\n  function error(e) {\n    reportGlobalError(response, e);\n  }\n  var streamState = {\n      _rowState: 0,\n      _rowID: 0,\n      _rowTag: 0,\n      _rowLength: 0,\n      _buffer: []\n    },\n    reader = stream.getReader();\n  reader.read().then(progress).catch(error);\n}\nexports.createFromFetch = function (promiseForResponse, options) {\n  var response = createResponseFromOptions(options);\n  promiseForResponse.then(\n    function (r) {\n      startReadingFromStream(response, r.body, close.bind(null, response));\n    },\n    function (e) {\n      reportGlobalError(response, e);\n    }\n  );\n  return getChunk(response, 0);\n};\nexports.createFromReadableStream = function (stream, options) {\n  options = createResponseFromOptions(options);\n  startReadingFromStream(options, stream, close.bind(null, options));\n  return getChunk(options, 0);\n};\nexports.createServerReference = function (id, callServer) {\n  function action() {\n    var args = Array.prototype.slice.call(arguments);\n    return callServer(id, args);\n  }\n  registerBoundServerReference(action, id, null);\n  return action;\n};\nexports.createTemporaryReferenceSet = function () {\n  return new Map();\n};\nexports.encodeReply = function (value, options) {\n  return new Promise(function (resolve, reject) {\n    var abort = processReply(\n      value,\n      \"\",\n      options && options.temporaryReferences\n        ? options.temporaryReferences\n        : void 0,\n      resolve,\n      reject\n    );\n    if (options && options.signal) {\n      var signal = options.signal;\n      if (signal.aborted) abort(signal.reason);\n      else {\n        var listener = function () {\n          abort(signal.reason);\n          signal.removeEventListener(\"abort\", listener);\n        };\n        signal.addEventListener(\"abort\", listener);\n      }\n    }\n  });\n};\nexports.registerServerReference = function (reference, id) {\n  registerBoundServerReference(reference, id, null);\n  return reference;\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.browser.production.js');\n} else {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.browser.development.js');\n}\n","'use strict';\n\nmodule.exports = require('./client.browser');\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\nexport const HTML_LIMITED_BOT_UA_RE =\n  /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i\n","import { HTML_LIMITED_BOT_UA_RE } from './html-bots'\n\n// Bot crawler that will spin up a headless browser and execute JS.\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i\n\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source\n\nexport { HTML_LIMITED_BOT_UA_RE }\n\nfunction isDomBotUA(userAgent: string) {\n  return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent)\n}\n\nfunction isHtmlLimitedBotUA(userAgent: string) {\n  return HTML_LIMITED_BOT_UA_RE.test(userAgent)\n}\n\nexport function isBot(userAgent: string): boolean {\n  return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent)\n}\n\nexport function getBotType(userAgent: string): 'dom' | 'html' | undefined {\n  if (isDomBotUA(userAgent)) {\n    return 'dom'\n  }\n  if (isHtmlLimitedBotUA(userAgent)) {\n    return 'html'\n  }\n  return undefined\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { NavigationSeed } from '../segment-cache/navigation'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  previousTree: FlightRouterState\n  url: URL\n  nextUrl: string | null\n  seed: NavigationSeed | null\n  mpa: boolean\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport type InterceptionMarker = (typeof INTERCEPTION_ROUTE_MARKERS)[number]\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\ntype InterceptionRouteInformation = {\n  /**\n   * The intercepting route. This is the route that is being intercepted or the\n   * route that the user was coming from. This is matched by the Next-Url\n   * header.\n   */\n  interceptingRoute: string\n\n  /**\n   * The intercepted route. This is the route that is being intercepted or the\n   * route that the user is going to. This is matched by the request pathname.\n   */\n  interceptedRoute: string\n}\n\nexport function extractInterceptionRouteInformation(\n  path: string\n): InterceptionRouteInformation {\n  let interceptingRoute: string | undefined\n  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n  let interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n","import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let previousNextUrl = state.previousNextUrl\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      previousNextUrl = nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n    renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? (mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths)\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n    previousNextUrl: previousNextUrl,\n    debugInfo: mutable.collectedDebugInfo ?? null,\n  }\n}\n","import { PAGE_SEGMENT_KEY } from '../segment'\nimport type { Segment as FlightRouterStateSegment } from '../app-router-types'\n\n// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\nexport type SegmentRequestKeyPart = Opaque<'SegmentRequestKeyPart', string>\nexport type SegmentRequestKey = Opaque<'SegmentRequestKey', string>\n\nexport const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey\n\nexport const HEAD_REQUEST_KEY = '/_head' as SegmentRequestKey\n\nexport function createSegmentRequestKeyPart(\n  segment: FlightRouterStateSegment\n): SegmentRequestKeyPart {\n  if (typeof segment === 'string') {\n    if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n      // The Flight Router State type sometimes includes the search params in\n      // the page segment. However, the Segment Cache tracks this as a separate\n      // key. So, we strip the search params here, and then add them back when\n      // the cache entry is turned back into a FlightRouterState. This is an\n      // unfortunate consequence of the FlightRouteState being used both as a\n      // transport type and as a cache key; we'll address this once more of the\n      // Segment Cache implementation has settled.\n      // TODO: We should hoist the search params out of the FlightRouterState\n      // type entirely, This is our plan for dynamic route params, too.\n      return PAGE_SEGMENT_KEY as SegmentRequestKeyPart\n    }\n    const safeName =\n      // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n      // But params typically don't include the leading slash. We should use\n      // a different encoding to avoid this special case.\n      segment === '/_not-found'\n        ? '_not-found'\n        : encodeToFilesystemAndURLSafeString(segment)\n    // Since this is not a dynamic segment, it's fully encoded. It does not\n    // need to be \"hydrated\" with a param value.\n    return safeName as SegmentRequestKeyPart\n  }\n\n  const name = segment[0]\n  const paramType = segment[2]\n  const safeName = encodeToFilesystemAndURLSafeString(name)\n\n  const encodedName = '$' + paramType + '$' + safeName\n  return encodedName as SegmentRequestKeyPart\n}\n\nexport function appendSegmentRequestKeyPart(\n  parentRequestKey: SegmentRequestKey,\n  parallelRouteKey: string,\n  childRequestKeyPart: SegmentRequestKeyPart\n): SegmentRequestKey {\n  // Aside from being filesystem safe, segment keys are also designed so that\n  // each segment and parallel route creates its own subdirectory. Roughly in\n  // the same shape as the source app directory. This is mostly just for easier\n  // debugging (you can open up the build folder and navigate the output); if\n  // we wanted to do we could just use a flat structure.\n\n  // Omit the parallel route key for children, since this is the most\n  // common case. Saves some bytes (and it's what the app directory does).\n  const slotKey =\n    parallelRouteKey === 'children'\n      ? childRequestKeyPart\n      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`\n  return (parentRequestKey + '/' + slotKey) as SegmentRequestKey\n}\n\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/\n\nfunction encodeToFilesystemAndURLSafeString(value: string) {\n  if (simpleParamValueRegex.test(value)) {\n    return value\n  }\n  // If there are any unsafe characters, base64url-encode the entire value.\n  // We also add a ! prefix so it doesn't collide with the simple case.\n  const base64url = btoa(value)\n    .replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n  return '!' + base64url\n}\n\nexport function convertSegmentPathToStaticExportFilename(\n  segmentPath: string\n): string {\n  return `__next${segmentPath.replace(/\\//g, '.')}.txt`\n}\n","import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n","import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str: string) {\n  let hash = 5381\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) + hash + char) & 0xffffffff\n  }\n  return hash >>> 0\n}\n\nexport function hexHash(str: string) {\n  return djb2Hash(str).toString(36).slice(0, 5)\n}\n","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport {\n  type NEXT_ROUTER_PREFETCH_HEADER,\n  type NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport {\n  getRenderedSearch,\n  urlToUrlWithoutFlightMarker,\n} from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\nimport { getDeploymentId } from '../../../shared/lib/deployment-id'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet isPageUnloading = false\n\nif (typeof window !== 'undefined') {\n  // Track when the page is unloading, e.g. due to reloading the page or\n  // performing hard navigations. This allows us to suppress error logging when\n  // the browser cancels in-flight requests during page unload.\n  window.addEventListener('pagehide', () => {\n    isPageUnloading = true\n  })\n\n  // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n  // execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    isPageUnloading = false\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      'auto',\n      shouldImmediatelyDecode\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      renderedSearch: getRenderedSearch(res),\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!isPageUnloading) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid  when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  ChildSegmentMap,\n  CacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  NOT_FOUND_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { dispatchAppRouterAction } from '../use-action-queue'\nimport {\n  ACTION_SERVER_PATCH,\n  type ServerPatchAction,\n} from './router-reducer-types'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\nimport {\n  convertServerPatchToFullTree,\n  type NavigationSeed,\n} from '../segment-cache/navigation'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type NavigationTask = {\n  status: NavigationTaskStatus\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents.\n  node: CacheNode\n  // The tree sent to the server during the dynamic request. If all the segments\n  // are static, then this will be null, and no server request is required.\n  // Otherwise, this is the same as `route`, except with the `refetch` marker\n  // set on the top-most segment that needs to be fetched.\n  dynamicRequestTree: FlightRouterState | null\n  // The URL that should be used to fetch the dynamic data. This is only set\n  // when the segment cannot be refetched from the current route, because it's\n  // part of a \"default\" parallel slot that was reused during a navigation.\n  refreshUrl: string | null\n  children: Map<string, NavigationTask> | null\n}\n\nexport const enum FreshnessPolicy {\n  Default,\n  Hydration,\n  HistoryTraversal,\n  RefreshAll,\n  HMRRefresh,\n}\n\nconst enum NavigationTaskStatus {\n  Pending,\n  Fulfilled,\n  Rejected,\n}\n\n/**\n * When a NavigationTask finishes, there may or may not be data still missing,\n * necessitating a retry.\n */\nconst enum NavigationTaskExitStatus {\n  /**\n   * No additional navigation is required.\n   */\n  Done = 0,\n  /**\n   * Some data failed to load, presumably due to a route tree mismatch. Perform\n   * a soft retry to reload the entire tree.\n   */\n  SoftRetry = 1,\n  /**\n   * Some data failed to load in an unrecoverable way, e.g. in an inactive\n   * parallel route. Fall back to a hard (MPA-style) retry.\n   */\n  HardRetry = 2,\n}\n\nexport type NavigationRequestAccumulation = {\n  scrollableSegments: Array<FlightSegmentPath> | null\n  separateRefreshUrls: Set<string> | null\n}\n\nconst noop = () => {}\n\nexport function createInitialCacheNodeForHydration(\n  navigatedAt: number,\n  initialTree: FlightRouterState,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData\n): CacheNode {\n  // Create the initial cache node tree, using the data embedded into the\n  // HTML document.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = createCacheNodeOnNavigation(\n    navigatedAt,\n    initialTree,\n    undefined,\n    FreshnessPolicy.Hydration,\n    seedData,\n    seedHead,\n    null,\n    null,\n    false,\n    null,\n    null,\n    false,\n    accumulation\n  )\n\n  // NOTE: We intentionally don't check if any data needs to be fetched from the\n  // server. We assume the initial hydration payload is sufficient to render\n  // the page.\n  //\n  // The completeness of the initial data is an important property that we rely\n  // on as a last-ditch mechanism for recovering the app; we must always be able\n  // to reload a fresh HTML document to get to a consistent state.\n  //\n  // In the future, there may be cases where the server intentionally sends\n  // partial data and expects the client to fill in the rest, in which case this\n  // logic may change. (There already is a similar case where the server sends\n  // _no_ hydration data in the HTML document at all, and the client fetches it\n  // separately, but that's different because we still end up hydrating with a\n  // complete tree.)\n\n  return task.node\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched  due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | null,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  const didFindRootLayout = false\n  const parentNeedsDynamicRequest = false\n  const parentRefreshUrl = null\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode !== null ? oldCacheNode : undefined,\n    oldRouterState,\n    newRouterState,\n    freshness,\n    didFindRootLayout,\n    seedData,\n    seedHead,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    null,\n    null,\n    parentNeedsDynamicRequest,\n    parentRefreshUrl,\n    accumulation\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | void,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  freshness: FreshnessPolicy,\n  didFindRootLayout: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  parentRefreshUrl: string | null,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  // Check if this segment matches the one in the previous route.\n  const oldSegment = oldRouterState[0]\n  const newSegment = newRouterState[0]\n  if (!matchSegment(newSegment, oldSegment)) {\n    // This segment does not match the previous route. We're now entering the\n    // new part of the target route. Switch to the \"create\" path.\n    if (\n      // Check if the route tree changed before we reached a layout. (The\n      // highest-level layout in a route tree is referred to as the \"root\"\n      // layout.) This could mean that we're navigating between two different\n      // root layouts. When this happens, we perform a full-page (MPA-style)\n      // navigation.\n      //\n      // However, the algorithm for deciding where to start rendering a route\n      // (i.e. the one performed in order to reach this function) is stricter\n      // than the one used to detect a change in the root layout. So just\n      // because we're re-rendering a segment outside of the root layout does\n      // not mean we should trigger a full-page navigation.\n      //\n      // Specifically, we handle dynamic parameters differently: two segments\n      // are considered the same even if their parameter values are different.\n      //\n      // Refer to isNavigatingToNewRootLayout for details.\n      //\n      // Note that we only have to perform this extra traversal if we didn't\n      // already discover a root layout in the part of the tree that is\n      // unchanged. We also only need to compare the subtree that is not\n      // shared. In the common case, this branch is skipped completely.\n      (!didFindRootLayout &&\n        isNavigatingToNewRootLayout(oldRouterState, newRouterState)) ||\n      // The global Not Found route (app/global-not-found.tsx) is a special\n      // case, because it acts like a root layout, but in the router tree, it\n      // is rendered in the same position as app/layout.tsx.\n      //\n      // Any navigation to the global Not Found route should trigger a\n      // full-page navigation.\n      //\n      // TODO: We should probably model this by changing the key of the root\n      // segment when this happens. Then the root layout check would work\n      // as expected, without a special case.\n      newSegment === NOT_FOUND_SEGMENT_KEY\n    ) {\n      return null\n    }\n    if (parentSegmentPath === null || parentParallelRouteKey === null) {\n      // The root should never mismatch. If it does, it suggests an internal\n      // Next.js error, or a malformed server response. Trigger a full-\n      // page navigation.\n      return null\n    }\n    return createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterState,\n      oldCacheNode,\n      freshness,\n      seedData,\n      seedHead,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      parentSegmentPath,\n      parentParallelRouteKey,\n      parentNeedsDynamicRequest,\n      accumulation\n    )\n  }\n\n  // TODO: The segment paths are tracked so that LayoutRouter knows which\n  // segments to scroll to after a navigation. But we should just mark this\n  // information on the CacheNode directly. It used to be necessary to do this\n  // separately because CacheNodes were created lazily during render, not when\n  // rather than when creating the route tree.\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const oldRouterStateChildren = oldRouterState[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  // We're currently traversing the part of the tree that was also part of\n  // the previous route. If we discover a root layout, then we don't need to\n  // trigger an MPA navigation.\n  const isRootLayout = newRouterState[4] === true\n  const childDidFindRootLayout = didFindRootLayout || isRootLayout\n\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  let shouldDropSiblingCaches: boolean = false\n  let shouldRefreshDynamicData: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n      // We should never drop dynamic data in shared layouts, except during\n      // a refresh.\n      shouldDropSiblingCaches = false\n      shouldRefreshDynamicData = false\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      shouldDropSiblingCaches = true\n      shouldRefreshDynamicData = true\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n  const newParallelRoutes = new Map(\n    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n  )\n\n  // TODO: We're not consistent about how we do this check. Some places\n  // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n  // check if there any any children, which is why I'm doing it here. We\n  // should probably encode an empty children set as `null` though. Either\n  // way, we should update all the checks to be consistent.\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  // Get the data for this segment. Since it was part of the previous route,\n  // usually we just clone the data from the old CacheNode. However, during a\n  // refresh or a revalidation, there won't be any existing CacheNode. So we\n  // may need to consult the prefetch cache, like we would for a new segment.\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (\n    oldCacheNode !== undefined &&\n    !shouldRefreshDynamicData &&\n    // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)\n  ) {\n    // Reuse the existing CacheNode\n    const dropPrefetchRsc = false\n    newCacheNode = reuseDynamicCacheNode(\n      dropPrefetchRsc,\n      oldCacheNode,\n      newParallelRoutes\n    )\n    needsDynamicRequest = false\n  } else if (seedData !== null && seedData[0] !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = seedHead === null\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt,\n      freshness\n    )\n    needsDynamicRequest = true\n  }\n\n  // During a refresh navigation, there's a special case that happens when\n  // entering a \"default\" slot. The default slot may not be part of the\n  // current route; it may have been reused from an older route. If so,\n  // we need to fetch its data from the old route's URL rather than current\n  // route's URL. Keep track of this as we traverse the tree.\n  const href = newRouterState[2]\n  const refreshUrl =\n    typeof href === 'string' && newRouterState[3] === 'refresh'\n      ? // This segment is not present in the current route. Track its\n        // refresh URL as we continue traversing the tree.\n        href\n      : // Inherit the refresh URL from the parent.\n        parentRefreshUrl\n\n  // If this segment itself needs to fetch new data from the server, then by\n  // definition it is being refreshed. Track its refresh URL so we know which\n  // URL to request the data from.\n  if (needsDynamicRequest && refreshUrl !== null) {\n    accumulateRefreshUrl(accumulation, refreshUrl)\n  }\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server  for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let childNeedsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n  // at the end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    let newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    if (oldRouterStateChild === undefined) {\n      // This should never happen, but if it does, it suggests a malformed\n      // server response. Trigger a full-page navigation.\n      return null\n    }\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n\n    let seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    let prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    let newSegmentChild = newRouterStateChild[0]\n    let seedHeadChild = seedHead\n    let prefetchHeadChild = prefetchHead\n    let isPrefetchHeadPartialChild = isPrefetchHeadPartial\n    if (\n      // Skip this branch during a history traversal. We restore the tree that\n      // was stashed in the history entry as-is.\n      freshness !== FreshnessPolicy.HistoryTraversal &&\n      newSegmentChild === DEFAULT_SEGMENT_KEY\n    ) {\n      // This is a \"default\" segment. These are never sent by the server during\n      // a soft navigation; instead, the client reuses whatever segment was\n      // already active in that slot on the previous route.\n      newRouterStateChild = reuseActiveSegmentInDefaultSlot(\n        oldUrl,\n        oldRouterStateChild\n      )\n      newSegmentChild = newRouterStateChild[0]\n\n      // Since we're switching to a different route tree, these are no\n      // longer valid, because they correspond to the outer tree.\n      seedDataChild = null\n      seedHeadChild = null\n      prefetchDataChild = null\n      prefetchHeadChild = null\n      isPrefetchHeadPartialChild = false\n    }\n\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = updateCacheNodeOnNavigation(\n      navigatedAt,\n      oldUrl,\n      oldCacheNodeChild,\n      oldRouterStateChild,\n      newRouterStateChild,\n      freshness,\n      childDidFindRootLayout,\n      seedDataChild ?? null,\n      seedHeadChild,\n      prefetchDataChild ?? null,\n      prefetchHeadChild,\n      isPrefetchHeadPartialChild,\n      isSamePageNavigation,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      refreshUrl,\n      accumulation\n    )\n\n    if (taskChild === null) {\n      // One of the child tasks discovered a change to the root layout.\n      // Immediately unwind from this recursive traversal. This will trigger a\n      // full-page navigation.\n      return null\n    }\n\n    // Recursively propagate up the child tasks.\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    // The child tree's route state may be different from the prefetched\n    // route sent by the server. We need to clone it as we traverse back up\n    // the tree.\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      // Something in the child tree is dynamic.\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    refreshUrl,\n    children: taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  newRouterState: FlightRouterState,\n  oldCacheNode: CacheNode | void,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n  // path once we reach the part of the tree that was not in the previous route.\n  // We don't need to diff against the old tree, we just need to create a new\n  // one. We also don't need to worry about any refresh-related logic.\n  //\n  // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n  // change that happens in this function likely needs to be applied to that\n  // one, too. However there are some places where the behavior intentionally\n  // diverges, which is why we keep them separate.\n\n  const newSegment = newRouterState[0]\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  let shouldDropSiblingCaches: boolean = false\n  let shouldRefreshDynamicData: boolean = false\n  let dropPrefetchRsc: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n      // We should never drop dynamic data in sibling caches except during\n      // a refresh.\n      shouldDropSiblingCaches = false\n\n      // Only reuse the dynamic data if experimental.staleTimes.dynamic config\n      // is set, and the data is not stale. (This is not a recommended API with\n      // Cache Components, but it's supported for backwards compatibility. Use\n      // cacheLife instead.)\n      //\n      // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased.\n      shouldRefreshDynamicData =\n        oldCacheNode === undefined ||\n        navigatedAt - oldCacheNode.navigatedAt >= DYNAMIC_STALETIME_MS\n\n      dropPrefetchRsc = false\n      break\n    case FreshnessPolicy.Hydration:\n      // During hydration, we assume the data sent by the server is both\n      // consistent and complete.\n      shouldRefreshDynamicData = false\n      shouldDropSiblingCaches = false\n      dropPrefetchRsc = false\n      break\n    case FreshnessPolicy.HistoryTraversal:\n      // During back/forward navigations, we reuse the dynamic data regardless\n      // of how stale it may be.\n      shouldRefreshDynamicData = false\n      shouldRefreshDynamicData = false\n\n      // Only show prefetched data if the dynamic data is still pending. This\n      // avoids a flash back to the prefetch state in a case where it's highly\n      // likely to have already streamed in.\n      //\n      // Tehnically, what we're actually checking is whether the dynamic network\n      // response was received. But since it's a streaming response, this does\n      // not mean that all the dynamic data has fully streamed in. It just means\n      // that _some_ of the dynamic data was received. But as a heuristic, we\n      // assume that the rest dynamic data will stream in quickly, so it's still\n      // better to skip the prefetch state.\n      if (oldCacheNode !== undefined) {\n        const oldRsc = oldCacheNode.rsc\n        const oldRscDidResolve =\n          !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending'\n        dropPrefetchRsc = oldRscDidResolve\n      } else {\n        dropPrefetchRsc = false\n      }\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      // Drop all dynamic data.\n      shouldRefreshDynamicData = true\n      shouldDropSiblingCaches = true\n      dropPrefetchRsc = false\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n\n  const newParallelRoutes = new Map(\n    shouldDropSiblingCaches ? undefined : oldParallelRoutes\n  )\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    //\n    // This only happens for new pages, not for refreshed pages.\n    //\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    if (accumulation.scrollableSegments === null) {\n      accumulation.scrollableSegments = []\n    }\n    accumulation.scrollableSegments.push(segmentPath)\n  }\n\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (!shouldRefreshDynamicData && oldCacheNode !== undefined) {\n    // Reuse the existing CacheNode\n    newCacheNode = reuseDynamicCacheNode(\n      dropPrefetchRsc,\n      oldCacheNode,\n      newParallelRoutes\n    )\n    needsDynamicRequest = false\n  } else if (seedData !== null && seedData[0] !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial =\n      seedHead === null && freshness !== FreshnessPolicy.Hydration\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (\n    freshness === FreshnessPolicy.Hydration &&\n    isLeafSegment &&\n    seedHead !== null\n  ) {\n    // This is another weird case related to \"not found\" pages and hydration.\n    // There will be a head sent by the server, but no page seed data.\n    // TODO: We really should get rid of all these \"not found\" specific quirks\n    // and make sure the tree is always consistent.\n    const seedRsc = null\n    const seedLoading = null\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = false\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = false\n  } else if (freshness !== FreshnessPolicy.Hydration && prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt,\n      freshness\n    )\n    needsDynamicRequest = true\n  }\n\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  let childNeedsDynamicRequest = false\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n    const seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterStateChild,\n      oldCacheNodeChild,\n      freshness,\n      seedDataChild ?? null,\n      seedHead,\n      prefetchDataChild ?? null,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      accumulation\n    )\n\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldDropSiblingCaches ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    // This route is not part of the current tree, so there's no reason to\n    // track the refresh URL.\n    refreshUrl: null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction createDynamicRequestTree(\n  newRouterState: FlightRouterState,\n  dynamicRequestTreeChildren: Record<string, FlightRouterState>,\n  needsDynamicRequest: boolean,\n  childNeedsDynamicRequest: boolean,\n  parentNeedsDynamicRequest: boolean\n): FlightRouterState | null {\n  // Create a FlightRouterState that instructs the server how to render the\n  // requested segment.\n  //\n  // Or, if neither this segment nor any of the children require a new data,\n  // then we return `null` to skip the request.\n  let dynamicRequestTree: FlightRouterState | null = null\n  if (needsDynamicRequest) {\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n    // The \"refetch\" marker is set on the top-most segment that requires new\n    // data. We can omit it if a parent was already marked.\n    if (!parentNeedsDynamicRequest) {\n      dynamicRequestTree[3] = 'refetch'\n    }\n  } else if (childNeedsDynamicRequest) {\n    // This segment does not request new data, but at least one of its\n    // children does.\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n  } else {\n    dynamicRequestTree = null\n  }\n  return dynamicRequestTree\n}\n\nfunction accumulateRefreshUrl(\n  accumulation: NavigationRequestAccumulation,\n  refreshUrl: string\n) {\n  // This is a refresh navigation, and we're inside a \"default\" slot that's\n  // not part of the current route; it was reused from an older route. In\n  // order to get fresh data for this reused route, we need to issue a\n  // separate request using the old route's URL.\n  //\n  // Track these extra URLs in the accumulated result. Later, we'll construct\n  // an appropriate request for each unique URL in the final set. The reason\n  // we don't do it immediately here is so we can deduplicate multiple\n  // instances of the same URL into a single request. See\n  // listenForDynamicRequest for more details.\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  if (separateRefreshUrls === null) {\n    accumulation.separateRefreshUrls = new Set([refreshUrl])\n  } else {\n    separateRefreshUrls.add(refreshUrl)\n  }\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): FlightRouterState {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return reusedRouterState\n}\n\nfunction reuseDynamicCacheNode(\n  dropPrefetchRsc: boolean,\n  existingCacheNode: CacheNode,\n  parallelRoutes: Map<string, ChildSegmentMap>\n): CacheNode {\n  // Clone an existing CacheNode's data, with (possibly) new children.\n  const cacheNode: CacheNode = {\n    rsc: existingCacheNode.rsc,\n    prefetchRsc: dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n    head: existingCacheNode.head,\n    prefetchHead: dropPrefetchRsc ? null : existingCacheNode.prefetchHead,\n    loading: existingCacheNode.loading,\n\n    parallelRoutes,\n\n    // Don't update the navigatedAt timestamp, since we're reusing\n    // existing data.\n    navigatedAt: existingCacheNode.navigatedAt,\n  }\n  return cacheNode\n}\n\nfunction readCacheNodeFromSeedData(\n  seedRsc: React.ReactNode,\n  seedLoading: LoadingModuleData | Promise<LoadingModuleData>,\n  isSeedRscPartial: boolean,\n  seedHead: HeadData | null,\n  isSeedHeadPartial: boolean,\n  isPageSegment: boolean,\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  navigatedAt: number\n): CacheNode {\n  // TODO: Currently this is threaded through the navigation logic using the\n  // CacheNodeSeedData type, but in the future this will read directly from\n  // the Segment Cache. See readRenderSnapshotFromCache.\n\n  let rsc: React.ReactNode\n  let prefetchRsc: React.ReactNode\n  if (isSeedRscPartial) {\n    // The prefetched data contains dynamic holes. Create a pending promise that\n    // will be fulfilled when the dynamic data is received from the server.\n    prefetchRsc = seedRsc\n    rsc = createDeferredRsc()\n  } else {\n    // The prefetched data is complete. Use it directly.\n    prefetchRsc = null\n    rsc = seedRsc\n  }\n\n  // If this is a page segment, also read the head.\n  let prefetchHead: HeadData | null\n  let head: HeadData | null\n  if (isPageSegment) {\n    if (isSeedHeadPartial) {\n      prefetchHead = seedHead\n      head = createDeferredRsc()\n    } else {\n      prefetchHead = null\n      head = seedHead\n    }\n  } else {\n    prefetchHead = null\n    head = null\n  }\n\n  const cacheNode: CacheNode = {\n    rsc,\n    prefetchRsc,\n    head,\n    prefetchHead,\n    // TODO: Technically, a loading boundary could contain dynamic data. We\n    // should have separate `loading` and `prefetchLoading` fields to handle\n    // this, like we do for the segment data and head.\n    loading: seedLoading,\n    parallelRoutes,\n    navigatedAt,\n  }\n\n  return cacheNode\n}\n\nfunction spawnNewCacheNode(\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  isLeafSegment: boolean,\n  navigatedAt: number,\n  freshness: FreshnessPolicy\n): CacheNode {\n  // We should never spawn network requests during hydration. We must treat the\n  // initial payload as authoritative, because the initial page load is used\n  // as a last-ditch mechanism for recovering the app.\n  //\n  // This is also an important safety check because if this leaks into the\n  // server rendering path (which theoretically it never should because\n  // the server payload should be consistent), the server would hang because\n  // these promises would never resolve.\n  //\n  // TODO: There is an existing case where the global \"not found\" boundary\n  // triggers this path. But it does render correctly despite that. That's an\n  // unusual render path so it's not surprising, but we should look into\n  // modeling it in a more consistent way. See also the /_notFound special\n  // case in updateCacheNodeOnNavigation.\n  const isHydration = freshness === FreshnessPolicy.Hydration\n\n  const cacheNode: CacheNode = {\n    rsc: !isHydration ? createDeferredRsc() : null,\n    prefetchRsc: null,\n    head: !isHydration && isLeafSegment ? createDeferredRsc() : null,\n    prefetchHead: null,\n    loading: !isHydration ? createDeferredRsc<LoadingModuleData>() : null,\n    parallelRoutes,\n    navigatedAt,\n  }\n  return cacheNode\n}\n\n// Represents whether the previuos navigation resulted in a route tree mismatch.\n// A mismatch results in a refresh of the page. If there are two successive\n// mismatches, we will fall back to an MPA navigation, to prevent a retry loop.\nlet previousNavigationDidMismatch = false\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for  everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function spawnDynamicRequests(\n  task: NavigationTask,\n  primaryUrl: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  accumulation: NavigationRequestAccumulation\n): void {\n  const dynamicRequestTree = task.dynamicRequestTree\n  if (dynamicRequestTree === null) {\n    // This navigation was fully cached. There are no dynamic requests to spawn.\n    previousNavigationDidMismatch = false\n    return\n  }\n\n  // This is intentionally not an async function to discourage the caller from\n  // awaiting the result. Any subsequent async operations spawned by this\n  // function should result in a separate navigation task, rather than\n  // block the original one.\n  //\n  // In this function we spawn (but do not await) all the network requests that\n  // block the navigation, and collect the promises. The next function,\n  // `finishNavigationTask`, can await the promises in any order without\n  // accidentally introducing a network waterfall.\n  const primaryRequestPromise = fetchMissingDynamicData(\n    task,\n    dynamicRequestTree,\n    primaryUrl,\n    nextUrl,\n    freshnessPolicy\n  )\n\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  let refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null = null\n  if (separateRefreshUrls !== null) {\n    // There are multiple URLs that we need to request the data from. This\n    // happens when a \"default\" parallel route slot is present in the tree, and\n    // its data cannot be fetched from the current route. We need to split the\n    // combined dynamic request tree into separate requests per URL.\n\n    // TODO: Create a scoped dynamic request tree that omits anything that\n    // is not relevant to the given URL. Without doing this, the server may\n    // sometimes render more data than necessary; this is not a regression\n    // compared to the pre-Segment Cache implementation, though, just an\n    // optimization we can make in the future.\n\n    // Construct a request tree for each additional refresh URL. This will\n    // prune away everything except the parts of the tree that match the\n    // given refresh URL.\n    refreshRequestPromises = []\n    const canonicalUrl = createHrefFromUrl(primaryUrl)\n    for (const refreshUrl of separateRefreshUrls) {\n      if (refreshUrl === canonicalUrl) {\n        // We already initiated a request for the this URL, above. Skip it.\n        // TODO: This only happens because the main URL is not tracked as\n        // part of the separateRefreshURLs set. There's probably a better way\n        // to structure this so this case doesn't happen.\n        continue\n      }\n      // TODO: Create a scoped dynamic request tree that omits anything that\n      // is not relevant to the given URL. Without doing this, the server may\n      // sometimes render more data than necessary; this is not a regression\n      // compared to the pre-Segment Cache implementation, though, just an\n      // optimization we can make in the future.\n      // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n      const scopedDynamicRequestTree = dynamicRequestTree\n      if (scopedDynamicRequestTree !== null) {\n        refreshRequestPromises.push(\n          fetchMissingDynamicData(\n            task,\n            scopedDynamicRequestTree,\n            new URL(refreshUrl, location.origin),\n            // TODO: Just noticed that this should actually the Next-Url at the\n            // time the refresh URL was set, not the current Next-Url. Need to\n            // start tracking this alongside the refresh URL. In the meantime,\n            // if a refresh fails due to a mismatch, it will trigger a\n            // hard refresh.\n            nextUrl,\n            freshnessPolicy\n          )\n        )\n      }\n    }\n  }\n\n  // Further async operations are moved into this separate function to\n  // discourage sequential network requests.\n  const voidPromise = finishNavigationTask(\n    task,\n    nextUrl,\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n  // `finishNavigationTask` is responsible for error handling, so we can attach\n  // noop callbacks to this promise.\n  voidPromise.then(noop, noop)\n}\n\nasync function finishNavigationTask(\n  task: NavigationTask,\n  nextUrl: string | null,\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n): Promise<void> {\n  // Wait for all the requests to finish, or for the first one to fail.\n  let exitStatus = await waitForRequestsToFinish(\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n\n  // Once the all the requests have finished, check the tree for any remaining\n  // pending tasks. If anything is still pending, it means the server response\n  // does not match the client, and we must refresh to get back to a consistent\n  // state. We can skip this step if we already detected a mismatch during the\n  // first phase; it doesn't matter in that case because we're going to refresh\n  // the whole tree regardless.\n  if (exitStatus === NavigationTaskExitStatus.Done) {\n    exitStatus = abortRemainingPendingTasks(task, null, null)\n  }\n\n  switch (exitStatus) {\n    case NavigationTaskExitStatus.Done: {\n      // The task has completely finished. There's no missing data. Exit.\n      previousNavigationDidMismatch = false\n      return\n    }\n    case NavigationTaskExitStatus.SoftRetry: {\n      // Some data failed to finish loading. Trigger a soft retry.\n      // TODO: As an extra precaution against soft retry loops, consider\n      // tracking whether a navigation was itself triggered by a retry. If two\n      // happen in a row, fall back to a hard retry.\n      const isHardRetry = false\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route\n      )\n      return\n    }\n    case NavigationTaskExitStatus.HardRetry: {\n      // Some data failed to finish loading in a non-recoverable way, such as a\n      // network error. Trigger an MPA navigation.\n      //\n      // Hard navigating/refreshing is how we prevent an infinite retry loop\n      // caused by a network error  when the network fails, we fall back to the\n      // browser behavior for offline navigations. In the future, Next.js may\n      // introduce its own custom handling of offline navigations, but that\n      // doesn't exist yet.\n      const isHardRetry = true\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route\n      )\n      return\n    }\n    default: {\n      return exitStatus satisfies never\n    }\n  }\n}\n\nfunction waitForRequestsToFinish(\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n) {\n  // Custom async combinator logic. This could be replaced by Promise.any but\n  // we don't assume that's available.\n  //\n  // Each promise resolves once the server responsds and the data is written\n  // into the CacheNode tree. Resolve the combined promise once all the\n  // requests finish.\n  //\n  // Or, resolve as soon as one of the requests fails, without waiting for the\n  // others to finish.\n  return new Promise<NavigationTaskExitStatus>((resolve) => {\n    const onFulfill = (result: { exitStatus: NavigationTaskExitStatus }) => {\n      if (result.exitStatus === NavigationTaskExitStatus.Done) {\n        remainingCount--\n        if (remainingCount === 0) {\n          // All the requests finished successfully.\n          resolve(NavigationTaskExitStatus.Done)\n        }\n      } else {\n        // One of the requests failed. Exit with a failing status.\n        // NOTE: It's possible for one of the requests to fail with SoftRetry\n        // and a later one to fail with HardRetry. In this case, we choose to\n        // retry immediately, rather than delay the retry until all the requests\n        // finish. If it fails again, we will hard retry on the next\n        // attempt, anyway.\n        resolve(result.exitStatus)\n      }\n    }\n    // onReject shouldn't ever be called because fetchMissingDynamicData's\n    // entire body is wrapped in a try/catch. This is just defensive.\n    const onReject = () => resolve(NavigationTaskExitStatus.HardRetry)\n\n    // Attach the listeners to the promises.\n    let remainingCount = 1\n    primaryRequestPromise.then(onFulfill, onReject)\n    if (refreshRequestPromises !== null) {\n      remainingCount += refreshRequestPromises.length\n      refreshRequestPromises.forEach((refreshRequestPromise) =>\n        refreshRequestPromise.then(onFulfill, onReject)\n      )\n    }\n  })\n}\n\nfunction dispatchRetryDueToTreeMismatch(\n  isHardRetry: boolean,\n  retryUrl: URL,\n  retryNextUrl: string | null,\n  seed: NavigationSeed | null,\n  baseTree: FlightRouterState\n) {\n  // If this is the second time in a row that a navigation resulted in a\n  // mismatch, fall back to a hard (MPA) refresh.\n  isHardRetry = isHardRetry || previousNavigationDidMismatch\n  previousNavigationDidMismatch = true\n  const retryAction: ServerPatchAction = {\n    type: ACTION_SERVER_PATCH,\n    previousTree: baseTree,\n    url: retryUrl,\n    nextUrl: retryNextUrl,\n    seed,\n    mpa: isHardRetry,\n  }\n  dispatchAppRouterAction(retryAction)\n}\n\nasync function fetchMissingDynamicData(\n  task: NavigationTask,\n  dynamicRequestTree: FlightRouterState,\n  url: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy\n): Promise<{\n  exitStatus: NavigationTaskExitStatus\n  url: URL\n  seed: NavigationSeed | null\n}> {\n  try {\n    const result = await fetchServerResponse(url, {\n      flightRouterState: dynamicRequestTree,\n      nextUrl,\n      isHmrRefresh: freshnessPolicy === FreshnessPolicy.HMRRefresh,\n    })\n    if (typeof result === 'string') {\n      // fetchServerResponse will return an href to indicate that the SPA\n      // navigation failed. For example, if the server triggered a hard\n      // redirect, or the fetch request errored. Initiate an MPA navigation\n      // to the given href.\n      return {\n        exitStatus: NavigationTaskExitStatus.HardRetry,\n        url: new URL(result, location.origin),\n        seed: null,\n      }\n    }\n    const seed = convertServerPatchToFullTree(\n      task.route,\n      result.flightData,\n      result.renderedSearch\n    )\n    const didReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(\n      task,\n      seed.tree,\n      seed.data,\n      seed.head,\n      result.debugInfo\n    )\n    return {\n      exitStatus: didReceiveUnknownParallelRoute\n        ? NavigationTaskExitStatus.SoftRetry\n        : NavigationTaskExitStatus.Done,\n      url: new URL(result.canonicalUrl, location.origin),\n      seed,\n    }\n  } catch {\n    // This shouldn't happen because fetchServerResponse's entire body is\n    // wrapped in a try/catch. If it does, though, it implies the server failed\n    // to respond with any tree at all. So we must fall back to a hard retry.\n    return {\n      exitStatus: NavigationTaskExitStatus.HardRetry,\n      url: url,\n      seed: null,\n    }\n  }\n}\n\nfunction writeDynamicDataIntoNavigationTask(\n  task: NavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData | null,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): boolean {\n  if (task.status === NavigationTaskStatus.Pending && dynamicData !== null) {\n    task.status = NavigationTaskStatus.Fulfilled\n    finishPendingCacheNode(task.node, dynamicData, dynamicHead, debugInfo)\n  }\n\n  const taskChildren = task.children\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData !== null ? dynamicData[1] : null\n\n  // Detect whether the server sends a parallel route slot that the client\n  // doesn't know about.\n  let didReceiveUnknownParallelRoute = false\n\n  if (taskChildren !== null) {\n    for (const parallelRouteKey in serverChildren) {\n      const serverRouterStateChild: FlightRouterState =\n        serverChildren[parallelRouteKey]\n      const dynamicDataChild: CacheNodeSeedData | null | void =\n        dynamicDataChildren !== null\n          ? dynamicDataChildren[parallelRouteKey]\n          : null\n\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild === undefined) {\n        // The server sent a child segment that the client doesn't know about.\n        //\n        // When we receive an unknown parallel route, we must consider it a\n        // mismatch. This is unlike the case where the segment itself\n        // mismatches, because multiple routes can be active simultaneously.\n        // But a given layout should never have a mismatching set of\n        // child slots.\n        //\n        // Theoretically, this should only happen in development during an HMR\n        // refresh, because the set of parallel routes for a layout does not\n        // change over the lifetime of a build/deployment. In production, we\n        // should have already mismatched on either the build id or the segment\n        // path. But as an extra precaution, we validate in prod, too.\n        didReceiveUnknownParallelRoute = true\n      } else {\n        const taskSegment = taskChild.route[0]\n        if (\n          matchSegment(serverRouterStateChild[0], taskSegment) &&\n          dynamicDataChild !== null &&\n          dynamicDataChild !== undefined\n        ) {\n          // Found a match for this task. Keep traversing down the task tree.\n          const childDidReceiveUnknownParallelRoute =\n            writeDynamicDataIntoNavigationTask(\n              taskChild,\n              serverRouterStateChild,\n              dynamicDataChild,\n              dynamicHead,\n              debugInfo\n            )\n          if (childDidReceiveUnknownParallelRoute) {\n            didReceiveUnknownParallelRoute = true\n          }\n        }\n      }\n    }\n  }\n\n  return didReceiveUnknownParallelRoute\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety  it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n\n  if (dynamicSegmentData === null) {\n    // This is an empty CacheNode; this particular server request did not\n    // render this segment. There may be a separate pending request that will,\n    // though, so we won't abort the task until all pending requests finish.\n    return\n  }\n\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nfunction abortRemainingPendingTasks(\n  task: NavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): NavigationTaskExitStatus {\n  let exitStatus\n  if (task.status === NavigationTaskStatus.Pending) {\n    // The data for this segment is still missing.\n    task.status = NavigationTaskStatus.Rejected\n    abortPendingCacheNode(task.node, error, debugInfo)\n\n    // If the server failed to fulfill the data for this segment, it implies\n    // that the route tree received from the server mismatched the tree that\n    // was previously prefetched.\n    //\n    // In an app with fully static routes and no proxy-driven redirects or\n    // rewrites, this should never happen, because the route for a URL would\n    // always be the same across multiple requests. So, this implies that some\n    // runtime routing condition changed, likely in a proxy, without being\n    // pushed to the client.\n    //\n    // When this happens, we treat this the same as a refresh(). The entire\n    // tree will be re-rendered from the root.\n    if (task.refreshUrl === null) {\n      // Trigger a \"soft\" refresh. Essentially the same as calling `refresh()`\n      // in a Server Action.\n      exitStatus = NavigationTaskExitStatus.SoftRetry\n    } else {\n      // The mismatch was discovered inside an inactive parallel route. This\n      // implies the inactive parallel route is no longer reachable at the URL\n      // that originally rendered it. Fall back to an MPA refresh.\n      // TODO: An alternative could be to trigger a soft refresh but to _not_\n      // re-use the inactive parallel routes this time. Similar to what would\n      // happen if were to do a hard refrehs, but without the HTML page.\n      exitStatus = NavigationTaskExitStatus.HardRetry\n    }\n  } else {\n    // This segment finished. (An error here is treated as Done because they are\n    // surfaced to the application during render.)\n    exitStatus = NavigationTaskExitStatus.Done\n  }\n\n  const taskChildren = task.children\n  if (taskChildren !== null) {\n    for (const [, taskChild] of taskChildren) {\n      const childExitStatus = abortRemainingPendingTasks(\n        taskChild,\n        error,\n        debugInfo\n      )\n      // Propagate the exit status up the tree. The statuses are ordered by\n      // their precedence.\n      if (childExitStatus > exitStatus) {\n        exitStatus = childExitStatus\n      }\n    }\n  }\n\n  return exitStatus\n}\n\nfunction abortPendingCacheNode(\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nexport function isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n","/**\n * App Router types - Client-safe types for the Next.js App Router\n *\n * This file contains type definitions that can be safely imported\n * by both client-side and server-side code without circular dependencies.\n */\n\nimport type React from 'react'\n\nexport type LoadingModuleData =\n  | [React.JSX.Element, React.ReactNode, React.ReactNode]\n  | null\n\n/** viewport metadata node */\nexport type HeadData = React.ReactNode\n\nexport type ChildSegmentMap = Map<string, CacheNode>\n\n/**\n * Cache node used in app-router / layout-router.\n */\n\nexport type CacheNode = {\n  /**\n   * When rsc is not null, it represents the RSC data for the\n   * corresponding segment.\n   *\n   * `null` is a valid React Node but because segment data is always a\n   * <LayoutRouter> component, we can use `null` to represent empty. When it is\n   * null, it represents missing data, and rendering should suspend.\n   */\n  rsc: React.ReactNode\n\n  /**\n   * Represents a static version of the segment that can be shown immediately,\n   * and may or may not contain dynamic holes. It's prefetched before a\n   * navigation occurs.\n   *\n   * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n   * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n   * no value was provided. In this case, the LayoutRouter will go straight to\n   * rendering the `rsc` value; if that one is also missing, it will suspend and\n   * trigger a lazy fetch.\n   */\n  prefetchRsc: React.ReactNode\n\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  /**\n   * The timestamp of the navigation that last updated the CacheNode's data. If\n   * a CacheNode is reused from a previous navigation, this value is not\n   * updated. Used to track the staleness of the data.\n   */\n  navigatedAt: number\n}\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted-(..)(..)'\n  | 'catchall-intercepted-(.)'\n  | 'catchall-intercepted-(..)'\n  | 'catchall-intercepted-(...)'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted-(..)(..)'\n  | 'dynamic-intercepted-(.)'\n  | 'dynamic-intercepted-(..)'\n  | 'dynamic-intercepted-(...)'\n\nexport type DynamicParamTypesShort =\n  | 'c'\n  | 'ci(..)(..)'\n  | 'ci(.)'\n  | 'ci(..)'\n  | 'ci(...)'\n  | 'oc'\n  | 'd'\n  | 'di(..)(..)'\n  | 'di(.)'\n  | 'di(..)'\n  | 'di(...)'\n\nexport type Segment =\n  | string\n  | [\n      // Param name\n      paramName: string,\n      // Param cache key (almost the same as the value, but arrays are\n      // concatenated into strings)\n      // TODO: We should change this to just be the value. Currently we convert\n      // it back to a value when passing to useParams. It only needs to be\n      // a string when converted to a a cache key, but that doesn't mean we\n      // need to store it as that representation.\n      paramCacheKey: string,\n      // Dynamic param type\n      dynamicParamType: DynamicParamTypesShort,\n    ]\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation  inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   * - \"metadata-only\" instructs the server to skip rendering the segments and\n   *   only send the head data.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case  during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?:\n    | 'refetch'\n    | 'refresh'\n    | 'inside-shared-layout'\n    | 'metadata-only'\n    | null,\n  isRootLayout?: boolean,\n  /**\n   * Only present when responding to a tree prefetch request. Indicates whether\n   * there is a loading boundary somewhere in the tree. The client cache uses\n   * this to determine if it can skip the data prefetch request.\n   */\n  hasLoadingBoundary?: HasLoadingBoundary,\n]\n\nexport const enum HasLoadingBoundary {\n  // There is a loading boundary in this particular segment\n  SegmentHasLoadingBoundary = 1,\n  // There is a loading boundary somewhere in the subtree (but not in\n  // this segment)\n  SubtreeHasLoadingBoundary = 2,\n  // There is no loading boundary in this segment or any of its descendants\n  SubtreeHasNoLoadingBoundary = 3,\n}\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  /** TODO: this doesn't feel like it belongs here, because it's only used during build, in `collectSegmentData` */\n  hasRuntimePrefetch: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** initialRenderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n  /** renderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** runtimePrefetch - [isPartial, staleTime]. Only present in runtime prefetch responses. */\n  rp?: [boolean, number]\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** renderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n","/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n","import { deleteMapEntry } from './cache-map'\nimport type { UnknownMapEntry } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\nlet head: UnknownMapEntry | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: UnknownMapEntry) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: UnknownMapEntry, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: UnknownMapEntry) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n        prev.next = next\n        next.prev = prev\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteMapEntry(tail)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n","import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Represents a node in the cache map and LRU.\n * MapEntry<V> structurally satisfies this interface for any V extends MapValue.\n *\n * The LRU can contain entries of different value types\n * (e.g., both RouteCacheEntry and SegmentCacheEntry). This interface captures\n * the common structure needed for cache map and LRU operations without\n * requiring knowledge of the specific value type.\n */\nexport interface MapEntry<V extends MapValue> {\n  // Cache map structure fields\n  parent: MapEntry<V> | null\n  key: unknown\n  map: Map<unknown, MapEntry<V>> | null\n  value: V | null\n\n  // LRU linked list fields\n  prev: MapEntry<V> | null\n  next: MapEntry<V> | null\n  size: number\n}\n\n/**\n * A looser type for MapEntry\n * This allows the LRU to work with entries of different\n * value types while still providing type safety.\n *\n * The `map` field lets Map<unknown, MapEntry<V>> be assignable to this\n * type since we're only reading from the map, not inserting into it.\n */\nexport type UnknownMapEntry = {\n  parent: UnknownMapEntry | null\n  key: unknown\n  map: Pick<Map<unknown, UnknownMapEntry>, 'get' | 'delete' | 'size'> | null\n  value: MapValue | null\n\n  prev: UnknownMapEntry | null\n  next: UnknownMapEntry | null\n  size: number\n}\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: MapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired(\n  now: number,\n  currentCacheVersion: number,\n  value: MapValue\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue(entry: UnknownMapEntry, value: MapValue): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n    entry.value = null\n  }\n\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  entry.value = value\n  value.ref = entry\n\n  updateLruSize(entry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap(value: MapValue): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef(value: MapValue): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nexport function deleteMapEntry(entry: UnknownMapEntry): void {\n  // Delete the entry from the cache.\n  entry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = entry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = entry.parent\n    let key = entry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(entry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n","import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    value: NormalizedPathname\n    parent: {\n      value: NormalizedSearch\n      parent: {\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    value: string\n    parent: {\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    value: pathname,\n    parent: {\n      value: search,\n      parent: {\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    value: requestKey,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it  for example, if the server tells us that the response\n  // doesn't vary on a particular param  but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        value: originalVaryPath.value,\n        parent: {\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    value: originalVaryPath.value,\n    parent: {\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n","// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n","import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  overwriteRevalidatingSegmentCacheEntry,\n  canNewFetchStrategyProvideMoreContent,\n} from './cache'\nimport { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './types'\nimport { getCurrentCacheVersion } from './cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache version at the time the task was initiated. This is used to\n   * determine if the cache was invalidated since the task was initiated.\n   */\n  cacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    cacheVersion: getCurrentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization  theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  const currentCacheVersion = getCurrentCacheVersion()\n  return (\n    task.cacheVersion !== currentCacheVersion ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.cacheVersion = getCurrentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.pathname, location.origin)\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          pingStaticHead(now, task, route)\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentRequestKey,\n              PendingSegmentCacheEntry\n            >()\n            pingRuntimeHead(\n              now,\n              task,\n              route,\n              spawnedEntries,\n              FetchStrategy.PPRRuntime\n            )\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentRequestKey,\n            PendingSegmentCacheEntry\n          >()\n          pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n          let needsDynamicRequest = spawnedEntries.size > 0\n          if (needsDynamicRequest) {\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingStaticHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry\n): void {\n  // The Head data for a page (metadata, viewport) is not really a route\n  // segment, in the sense that it doesn't appear in the route tree. But we\n  // store it in the cache as if it were, using a special key.\n  pingStaticSegmentData(\n    now,\n    task,\n    route,\n    readOrCreateSegmentCacheEntry(\n      now,\n      FetchStrategy.PPR,\n      route,\n      route.metadata\n    ),\n    task.key,\n    route.metadata\n  )\n}\n\nfunction pingRuntimeHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): void {\n  pingRouteTreeAndIncludeDynamicData(\n    now,\n    task,\n    route,\n    route.metadata,\n    false,\n    spawnedEntries,\n    // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary\n      ? FetchStrategy.Full\n      : fetchStrategy\n  )\n}\n\n// TODO: Rename dynamic -> runtime throughout this module\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree  the part that doesn't exist on the current page  we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    newTree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static  once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.requestKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch  via <Link prefetch={true}>  implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state  it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree\n  )\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.requestKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    route,\n    tree\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.requestKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response  it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    FetchStrategy.PPR,\n    route,\n    tree\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        ),\n        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    fetchStrategy,\n    route,\n    tree\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      waitForSegmentCacheEntry(pendingSegment),\n      getSegmentVaryPathForRequest(fetchStrategy, tree)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n        fetchStrategy,\n        route,\n        tree\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        waitForSegmentCacheEntry(pendingSegment),\n        getSegmentVaryPathForRequest(fetchStrategy, tree)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  promise: Promise<FulfilledSegmentCacheEntry | null>,\n  varyPath: SegmentVaryPath\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in  is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n","/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nexport function parsePath(path: string) {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery\n        ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)\n        : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return { pathname: path, query: '', hash: '' }\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string) {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n","/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */\nexport function removeTrailingSlash(route: string) {\n  return route.replace(/\\/$/, '') || '/'\n}\n","import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n","import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n","import { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n","import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n","export function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n  // Shim of Stage 4 Promise.withResolvers proposal\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { resolve: resolve!, reject: reject!, promise }\n}\n","import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type { LoadingModuleData } from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  finalizeMetadataVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type { NormalizedSearch, RouteCacheKey } from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type UnknownMapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: SegmentVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: boolean\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // Increment the current cache version. This does not eagerly evict anything\n  // from the cache, but because all the entries are versioned, and we check\n  // the version when reading from the cache, this effectively causes all\n  // entries to be evicted lazily. We do it lazily because in the future,\n  // actions like revalidateTag or refresh will not evict the entire cache,\n  // but rather some subset of the entries.\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it  i.e. the one\n  // optionally passed to router.prefetch(onInvalidate)  then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentCacheVersion(),\n  }\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete  this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    loading: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n\n  if (fetchStrategy === FetchStrategy.Full) {\n    // We can assume the response will contain the full segment data. Set this\n    // to false so we know it's OK to omit this segment from any navigation\n    // requests that may happen while the data is still pending.\n    pendingEntry.isPartial = false\n  }\n\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the global cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentCacheVersion()\n  return pendingEntry\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = metadata\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey\n        )\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    partialVaryPath = appendLayoutVaryPath(parentPartialVaryPath, paramCacheKey)\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    varyPath,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, previously we perform a range\n      // request of 64 bytes of the HTML document to check if the target page\n      // is part of this app (by checking if build id matches). Only if the target\n      // page is part of this app do we determine the final canonical URL.\n      //\n      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n      // do not support range requests, in the worst case, the entire HTML instead\n      // of 64 bytes could be returned, which is wasteful.\n      //\n      // So instead, we drops the check for build id here, and simply perform\n      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n      // final URL after redirects.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const headResponse = await fetch(url, {\n        method: 'HEAD',\n      })\n      if (headResponse.status < 200 || headResponse.status >= 400) {\n        // The target page responded w/o a successful status code\n        // Could be a WAF serving a 403, or a 5xx from a backend\n        //\n        // Note that we can't use headResponse.ok here, because\n        // Response#ok returns `false` with 3xx responses.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      urlAfterRedirects = headResponse.redirected\n        ? new URL(headResponse.url)\n        : url\n\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        metadataVaryPath,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert  should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time  it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    routeTree,\n    metadataVaryPath,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        route,\n        head,\n        null,\n        flightData.isHeadPartial,\n        staleAt,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    route,\n    rsc,\n    loading,\n    isPartial,\n    staleAt,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          route,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  staleAt: number,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentVaryPathForRequest(fetchStrategy, tree),\n        newEntry\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  spawnDynamicRequests,\n  FreshnessPolicy,\n  type NavigationTask,\n  type NavigationRequestAccumulation,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  requestOptimisticRouteCacheEntry,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { createCacheKey } from './cache-key'\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\nimport { NavigationResultTag } from './types'\n\ntype MPANavigationResult = {\n  tag: NavigationResultTag.MPA\n  data: string\n}\n\ntype SuccessfulNavigationResult = {\n  tag: NavigationResultTag.Success\n  data: {\n    flightRouterState: FlightRouterState\n    cacheNode: CacheNode\n    canonicalUrl: string\n    renderedSearch: string\n    scrollableSegments: Array<FlightSegmentPath> | null\n    shouldScroll: boolean\n    hash: string\n  }\n}\n\ntype AsyncNavigationResult = {\n  tag: NavigationResultTag.Async\n  data: Promise<MPANavigationResult | SuccessfulNavigationResult>\n}\n\nexport type NavigationResult =\n  | MPANavigationResult\n  | SuccessfulNavigationResult\n  | AsyncNavigationResult\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  url: URL,\n  currentUrl: URL,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  accumulation: { collectedDebugInfo?: Array<unknown> }\n): NavigationResult {\n  const now = Date.now()\n  const href = url.href\n\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation = href === currentUrl.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n    const prefetchFlightRouterState = snapshot.flightRouterState\n    const prefetchSeedData = snapshot.seedData\n    const headSnapshot = readHeadSnapshotFromCache(now, route)\n    const prefetchHead = headSnapshot.rsc\n    const isPrefetchHeadPartial = headSnapshot.isPartial\n    // TODO: The \"canonicalUrl\" stored in the cache doesn't include the hash,\n    // because hash entries do not vary by hash fragment. However, the one\n    // we set in the router state *does* include the hash, and it's used to\n    // sync with the actual browser location. To make this less of a refactor\n    // hazard, we should always track the hash separately from the rest of\n    // the URL.\n    const newCanonicalUrl = route.canonicalUrl + url.hash\n    const renderedSearch = route.renderedSearch\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      prefetchFlightRouterState,\n      prefetchSeedData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      newCanonicalUrl,\n      renderedSearch,\n      freshnessPolicy,\n      shouldScroll\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (route === null || route.status !== EntryStatus.Rejected) {\n    const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n    if (optimisticRoute !== null) {\n      // We have an optimistic route tree. Proceed with the normal flow.\n      const snapshot = readRenderSnapshotFromCache(\n        now,\n        optimisticRoute,\n        optimisticRoute.tree\n      )\n      const prefetchFlightRouterState = snapshot.flightRouterState\n      const prefetchSeedData = snapshot.seedData\n      const headSnapshot = readHeadSnapshotFromCache(now, optimisticRoute)\n      const prefetchHead = headSnapshot.rsc\n      const isPrefetchHeadPartial = headSnapshot.isPartial\n      const newCanonicalUrl = optimisticRoute.canonicalUrl + url.hash\n      const newRenderedSearch = optimisticRoute.renderedSearch\n      return navigateUsingPrefetchedRouteTree(\n        now,\n        url,\n        currentUrl,\n        nextUrl,\n        isSamePageNavigation,\n        currentCacheNode,\n        currentFlightRouterState,\n        prefetchFlightRouterState,\n        prefetchSeedData,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newCanonicalUrl,\n        newRenderedSearch,\n        freshnessPolicy,\n        shouldScroll\n      )\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache.\n  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n  if (accumulation.collectedDebugInfo === undefined) {\n    collectedDebugInfo = accumulation.collectedDebugInfo = []\n  }\n  return {\n    tag: NavigationResultTag.Async,\n    data: navigateDynamicallyWithNoPrefetch(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      currentCacheNode,\n      currentFlightRouterState,\n      freshnessPolicy,\n      shouldScroll,\n      collectedDebugInfo\n    ),\n  }\n}\n\nexport function navigateToSeededRoute(\n  now: number,\n  url: URL,\n  canonicalUrl: string,\n  navigationSeed: NavigationSeed,\n  currentUrl: URL,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  nextUrl: string | null,\n  shouldScroll: boolean\n): SuccessfulNavigationResult | MPANavigationResult {\n  // A version of navigate() that accepts the target route tree as an argument\n  // rather than reading it from the prefetch cache.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const isSamePageNavigation = url.href === currentUrl.href\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    navigationSeed.tree,\n    freshnessPolicy,\n    navigationSeed.data,\n    navigationSeed.head,\n    null,\n    null,\n    false,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation)\n    return navigationTaskToResult(\n      task,\n      canonicalUrl,\n      navigationSeed.renderedSearch,\n      accumulation.scrollableSegments,\n      shouldScroll,\n      url.hash\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return {\n    tag: NavigationResultTag.MPA,\n    data: canonicalUrl,\n  }\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  prefetchFlightRouterState: FlightRouterState,\n  prefetchSeedData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  canonicalUrl: string,\n  renderedSearch: string,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean\n): SuccessfulNavigationResult | MPANavigationResult {\n  // Recursively construct a prefetch tree by reading from the Segment Cache. To\n  // maintain compatibility, we output the same data structures as the old\n  // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n  // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n  // read from the Segment Cache directly. It's only structured this way for now\n  // so we can share code with the old prefetching implementation.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const seedData = null\n  const seedHead = null\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    freshnessPolicy,\n    seedData,\n    seedHead,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    spawnDynamicRequests(task, url, nextUrl, freshnessPolicy, accumulation)\n    return navigationTaskToResult(\n      task,\n      canonicalUrl,\n      renderedSearch,\n      accumulation.scrollableSegments,\n      shouldScroll,\n      url.hash\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return {\n    tag: NavigationResultTag.MPA,\n    data: canonicalUrl,\n  }\n}\n\nfunction navigationTaskToResult(\n  task: NavigationTask,\n  canonicalUrl: string,\n  renderedSearch: string,\n  scrollableSegments: Array<FlightSegmentPath> | null,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | MPANavigationResult {\n  return {\n    tag: NavigationResultTag.Success,\n    data: {\n      flightRouterState: task.route,\n      cacheNode: task.node,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash,\n    },\n  }\n}\n\nfunction readRenderSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n  let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n  let childSeedDatas: {\n    [parallelRouteKey: string]: CacheNodeSeedData | null\n  } = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n      childRouterStates[parallelRouteKey] = childResult.flightRouterState\n      childSeedDatas[parallelRouteKey] = childResult.seedData\n    }\n  }\n\n  let rsc: React.ReactNode | null = null\n  let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n  let isPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        rsc = segmentEntry.rsc\n        loading = segmentEntry.loading\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        loading = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.loading : null\n        )\n        // Because the request is still pending, we typically don't know yet\n        // whether the response will be partial. We shouldn't skip this segment\n        // during the dynamic navigation request. Otherwise, we might need to\n        // do yet another request to fill in the remaining data, creating\n        // a waterfall.\n        //\n        // The one exception is if this segment is being fetched with via\n        // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n        // we can assume the response will be full. This field is set to `false`\n        // for such segments.\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n\n  // The navigation implementation expects the search params to be\n  // included in the segment. However, the Segment Cache tracks search\n  // params separately from the rest of the segment key. So we need to\n  // add them back here.\n  //\n  // See corresponding comment in convertFlightRouterStateToTree.\n  //\n  // TODO: What we should do instead is update the navigation diffing\n  // logic to compare search params explicitly. This is a temporary\n  // solution until more of the Segment Cache implementation has settled.\n  const segment = addSearchParamsIfPageSegment(\n    tree.segment,\n    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n  )\n\n  // We don't need this information in a render snapshot, so this can just be a placeholder.\n  const hasRuntimePrefetch = false\n\n  return {\n    flightRouterState: [\n      segment,\n      childRouterStates,\n      null,\n      null,\n      tree.isRootLayout,\n    ],\n    seedData: [rsc, childSeedDatas, loading, isPartial, hasRuntimePrefetch],\n  }\n}\n\nfunction readHeadSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry\n): { rsc: HeadData; isPartial: boolean } {\n  // Same as readRenderSnapshotFromCache, but for the head\n  let rsc: React.ReactNode | null = null\n  let isPartial: boolean = true\n  const segmentEntry = readSegmentCacheEntry(now, route.metadata.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        rsc = segmentEntry.rsc\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n  return { rsc, isPartial }\n}\n\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute: FlightRouterState = [\n  '',\n  {},\n  null,\n  'refetch',\n]\n\nasync function navigateDynamicallyWithNoPrefetch(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  collectedDebugInfo: Array<unknown>\n): Promise<MPANavigationResult | SuccessfulNavigationResult> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  let dynamicRequestTree: FlightRouterState\n  switch (freshnessPolicy) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n      dynamicRequestTree = currentFlightRouterState\n      break\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      dynamicRequestTree = DynamicRequestTreeForEntireRoute\n      break\n    default:\n      freshnessPolicy satisfies never\n      dynamicRequestTree = currentFlightRouterState\n      break\n  }\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: dynamicRequestTree,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const newUrl = result\n    return {\n      tag: NavigationResultTag.MPA,\n      data: newUrl,\n    }\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    debugInfo: debugInfoFromResponse,\n  } = result\n  if (debugInfoFromResponse !== null) {\n    collectedDebugInfo.push(...debugInfoFromResponse)\n  }\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const navigationSeed = convertServerPatchToFullTree(\n    currentFlightRouterState,\n    flightData,\n    renderedSearch\n  )\n\n  return navigateToSeededRoute(\n    now,\n    url,\n    createHrefFromUrl(canonicalUrl),\n    navigationSeed,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll\n  )\n}\n\nexport type NavigationSeed = {\n  tree: FlightRouterState\n  renderedSearch: string\n  data: CacheNodeSeedData | null\n  head: HeadData | null\n}\n\nexport function convertServerPatchToFullTree(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData>,\n  renderedSearch: string\n): NavigationSeed {\n  // During a client navigation or prefetch, the server sends back only a patch\n  // for the parts of the tree that have changed.\n  //\n  // This applies the patch to the base tree to create a full representation of\n  // the resulting tree.\n  //\n  // The return type includes a full FlightRouterState tree and a full\n  // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n  // eventually be unified, but there's still lots of existing code that\n  // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n  //\n  // TODO: This similar to what apply-router-state-patch-to-tree does. It\n  // will eventually fully replace it. We should get rid of all the remaining\n  // places where we iterate over the server patch format. This should also\n  // eventually replace normalizeFlightData.\n\n  let baseTree: FlightRouterState = currentTree\n  let baseData: CacheNodeSeedData | null = null\n  let head: HeadData | null = null\n  for (const {\n    segmentPath,\n    tree: treePatch,\n    seedData: dataPatch,\n    head: headPatch,\n  } of flightData) {\n    const result = convertServerPatchToFullTreeImpl(\n      baseTree,\n      baseData,\n      treePatch,\n      dataPatch,\n      segmentPath,\n      0\n    )\n    baseTree = result.tree\n    baseData = result.data\n    // This is the same for all patches per response, so just pick an\n    // arbitrary one\n    head = headPatch\n  }\n\n  return {\n    tree: baseTree,\n    data: baseData,\n    renderedSearch,\n    head,\n  }\n}\n\nfunction convertServerPatchToFullTreeImpl(\n  baseRouterState: FlightRouterState,\n  baseData: CacheNodeSeedData | null,\n  treePatch: FlightRouterState,\n  dataPatch: CacheNodeSeedData | null,\n  segmentPath: FlightSegmentPath,\n  index: number\n): { tree: FlightRouterState; data: CacheNodeSeedData | null } {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return {\n      tree: treePatch,\n      data: dataPatch,\n    }\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: We receive the FlightRouterState patch in the same request as the\n  // seed data patch. Therefore we don't need to worry about diffing the segment\n  // values; we can assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseTreeChildren = baseRouterState[1]\n  const baseSeedDataChildren = baseData !== null ? baseData[1] : null\n  const newTreeChildren: Record<string, FlightRouterState> = {}\n  const newSeedDataChildren: Record<string, CacheNodeSeedData | null> = {}\n  for (const parallelRouteKey in baseTreeChildren) {\n    const childBaseRouterState = baseTreeChildren[parallelRouteKey]\n    const childBaseSeedData =\n      baseSeedDataChildren !== null\n        ? (baseSeedDataChildren[parallelRouteKey] ?? null)\n        : null\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const result = convertServerPatchToFullTreeImpl(\n        childBaseRouterState,\n        childBaseSeedData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        // Advance the index by two and keep cloning until we reach\n        // the end of the segment path.\n        index + 2\n      )\n\n      newTreeChildren[parallelRouteKey] = result.tree\n      newSeedDataChildren[parallelRouteKey] = result.data\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newTreeChildren[parallelRouteKey] = childBaseRouterState\n      newSeedDataChildren[parallelRouteKey] = childBaseSeedData\n    }\n  }\n\n  let clonedTree: FlightRouterState\n  let clonedSeedData: CacheNodeSeedData\n  // Clone all the fields except the children.\n\n  // Clone the FlightRouterState tree. Based on equivalent logic in\n  // apply-router-state-patch-to-tree, but should confirm whether we need to\n  // copy all of these fields. Not sure the server ever sends, e.g. the\n  // refetch marker.\n  clonedTree = [baseRouterState[0], newTreeChildren]\n  if (2 in baseRouterState) {\n    clonedTree[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clonedTree[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clonedTree[4] = baseRouterState[4]\n  }\n\n  // Clone the CacheNodeSeedData tree.\n  const isEmptySeedDataPartial = true\n  clonedSeedData = [\n    null,\n    newSeedDataChildren,\n    null,\n    isEmptySeedDataPartial,\n    false,\n  ]\n\n  return {\n    tree: clonedTree,\n    data: clonedSeedData,\n  }\n}\n","import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\nimport { NavigationResultTag } from '../../segment-cache/types'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nexport function handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n      // some confusing and subtle logic in `handleMutable` that decides what\n      // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n      // not convinced it's totally coherent but the tests assert on this\n      // particular behavior so I've ported the logic as-is from the previous\n      // router implementation, for now.\n      mutable.scrollableSegments = result.data.scrollableSegments ?? undefined\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    FreshnessPolicy.Default,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n","import type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (\n    Array.isArray(segment) &&\n    (segment[2] === 'di(..)(..)' ||\n      segment[2] === 'ci(..)(..)' ||\n      segment[2] === 'di(.)' ||\n      segment[2] === 'ci(.)' ||\n      segment[2] === 'di(..)' ||\n      segment[2] === 'ci(..)' ||\n      segment[2] === 'di(...)' ||\n      segment[2] === 'ci(...)')\n  ) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","import type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function refreshReducer(state: ReadonlyReducerState): ReducerState {\n  // TODO: Currently, all refreshes purge the prefetch cache. In the future,\n  // only client-side refreshes will have this behavior; the server-side\n  // `refresh` should send new data without purging the prefetch cache.\n  const currentNextUrl = state.nextUrl\n  const currentRouterState = state.tree\n  revalidateEntireCache(currentNextUrl, currentRouterState)\n  return refreshDynamicData(state, FreshnessPolicy.RefreshAll)\n}\n\nexport function refreshDynamicData(\n  state: ReadonlyReducerState,\n  freshnessPolicy: FreshnessPolicy.RefreshAll | FreshnessPolicy.HMRRefresh\n): ReducerState {\n  const currentNextUrl = state.nextUrl\n\n  // We always send the last next-url, not the current when performing a dynamic\n  // request. This is because we update the next-url after a navigation, but we\n  // want the same interception route to be matched that used the last next-url.\n  const nextUrlForRefresh = hasInterceptionRouteInCurrentTree(state.tree)\n    ? state.previousNextUrl || currentNextUrl\n    : null\n\n  // A refresh is modeled as a navigation to the current URL, but where any\n  // existing dynamic data (including in shared layouts) is re-fetched.\n  const currentCanonicalUrl = state.canonicalUrl\n  const currentUrl = new URL(currentCanonicalUrl, location.origin)\n  const currentFlightRouterState = state.tree\n  const shouldScroll = true\n\n  const navigationSeed = {\n    tree: state.tree,\n    renderedSearch: state.renderedSearch,\n    data: null,\n    head: null,\n  }\n\n  const now = Date.now()\n  const result = navigateToSeededRoute(\n    now,\n    currentUrl,\n    currentCanonicalUrl,\n    navigationSeed,\n    currentUrl,\n    state.cache,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrlForRefresh,\n    shouldScroll\n  )\n\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  return handleNavigationResult(currentUrl, state, mutable, false, result)\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { refreshReducer } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  // A \"retry\" is a navigation that happens due to a route mismatch. It's\n  // similar to a refresh, because we will omit any existing dynamic data on\n  // the page. But we seed the retry navigation with the exact tree that the\n  // server just responded with.\n  const retryMpa = action.mpa\n  const retryUrl = new URL(action.url, location.origin)\n  const retrySeed = action.seed\n  if (retryMpa || retrySeed === null) {\n    // If the server did not send back data during the mismatch, fall back to\n    // an MPA navigation.\n    return handleExternalUrl(state, mutable, retryUrl.href, false)\n  }\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  if (action.previousTree !== state.tree) {\n    // There was another, more recent navigation since the once that\n    // mismatched. We can abort the retry, but we still need to refresh the\n    // page to evict any stale dynamic data.\n    return refreshReducer(state)\n  }\n  // There have been no new navigations since the mismatched one. Refresh,\n  // using the tree we just received from the server.\n  const retryCanonicalUrl = createHrefFromUrl(retryUrl)\n  const retryNextUrl = action.nextUrl\n  // A retry should not create a new history entry.\n  const pendingPush = false\n  const shouldScroll = true\n  const now = Date.now()\n  const result = navigateToSeededRoute(\n    now,\n    retryUrl,\n    retryCanonicalUrl,\n    retrySeed,\n    currentUrl,\n    state.cache,\n    state.tree,\n    FreshnessPolicy.RefreshAll,\n    retryNextUrl,\n    shouldScroll\n  )\n  return handleNavigationResult(retryUrl, state, mutable, pendingPush, result)\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport {\n  FreshnessPolicy,\n  spawnDynamicRequests,\n  startPPRNavigation,\n  type NavigationRequestAccumulation,\n} from '../ppr-navigations'\nimport type { FlightRouterState } from '../../../../shared/lib/app-router-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport type { Mutable } from '../router-reducer-types'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  let treeToRestore: FlightRouterState | undefined\n  let renderedSearch: string | undefined\n  const historyState = action.historyState\n  if (historyState) {\n    treeToRestore = historyState.tree\n    renderedSearch = historyState.renderedSearch\n  } else {\n    treeToRestore = state.tree\n    renderedSearch = state.renderedSearch\n  }\n\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const restoredUrl = action.url\n  const restoredCanonicalUrl = createHrefFromUrl(restoredUrl)\n  const restoredNextUrl =\n    extractPathFromFlightRouterState(treeToRestore) ?? restoredUrl.pathname\n\n  const now = Date.now()\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    state.cache,\n    state.tree,\n    treeToRestore,\n    FreshnessPolicy.HistoryTraversal,\n    null,\n    null,\n    null,\n    null,\n    false,\n    false,\n    accumulation\n  )\n\n  if (task === null) {\n    const mutable: Mutable = {\n      preserveCustomHistoryState: true,\n    }\n    return handleExternalUrl(state, mutable, restoredCanonicalUrl, false)\n  }\n\n  spawnDynamicRequests(\n    task,\n    restoredUrl,\n    restoredNextUrl,\n    FreshnessPolicy.HistoryTraversal,\n    accumulation\n  )\n\n  return {\n    // Set canonical url\n    canonicalUrl: restoredCanonicalUrl,\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: task.node,\n    // Restore provided tree\n    tree: treeToRestore,\n\n    nextUrl: restoredNextUrl,\n    // TODO: We need to restore previousNextUrl, too, which represents the\n    // Next-Url that was used to fetch the data. Anywhere we fetch using the\n    // canonical URL, there should be a corresponding Next-Url.\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n","import type {\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { refreshDynamicData } from './refresh-reducer'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nexport function hmrRefreshReducer(state: ReadonlyReducerState): ReducerState {\n  return refreshDynamicData(state, FreshnessPolicy.HMRRefresh)\n}\n","import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */\nexport function pathHasPrefix(path: string, prefix: string) {\n  if (typeof path !== 'string') {\n    return false\n  }\n\n  const { pathname } = parsePath(path)\n  return pathname === prefix || pathname.startsWith(prefix + '/')\n}\n","import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n","import { hasBasePath } from './has-base-path'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function removeBasePath(path: string): string {\n  if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n    if (!hasBasePath(path)) {\n      return path\n    }\n  }\n\n  // Can't trim the basePath if it has zero length!\n  if (basePath.length === 0) return path\n\n  path = path.slice(basePath.length)\n  if (!path.startsWith('/')) path = `/${path}`\n  return path\n}\n","export interface ServerReferenceInfo {\n  type: 'server-action' | 'use-cache'\n  usedArgs: [boolean, boolean, boolean, boolean, boolean, boolean]\n  hasRestArgs: boolean\n}\n\n/**\n * Extracts info about the server reference for the given server reference ID by\n * parsing the first byte of the hex-encoded ID.\n *\n * ```\n * Bit positions: [7]      [6] [5] [4] [3] [2] [1]  [0]\n * Bits:          typeBit  argMask                  restArgs\n * ```\n *\n * If the `typeBit` is `1` the server reference represents a `\"use cache\"`\n * function, otherwise a server action.\n *\n * The `argMask` encodes whether the function uses the argument at the\n * respective position.\n *\n * The `restArgs` bit indicates whether the function uses a rest parameter. It's\n * also set to 1 if the function has more than 6 args.\n *\n * @param id hex-encoded server reference ID\n */\nexport function extractInfoFromServerReferenceId(\n  id: string\n): ServerReferenceInfo {\n  const infoByte = parseInt(id.slice(0, 2), 16)\n  const typeBit = (infoByte >> 7) & 0x1\n  const argMask = (infoByte >> 1) & 0x3f\n  const restArgs = infoByte & 0x1\n  const usedArgs = Array(6)\n\n  for (let index = 0; index < 6; index++) {\n    const bitPosition = 5 - index\n    const bit = (argMask >> bitPosition) & 0x1\n    usedArgs[index] = bit === 1\n  }\n\n  return {\n    type: typeBit === 1 ? 'use-cache' : 'server-action',\n    usedArgs: usedArgs as [\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n    ],\n    hasRestArgs: restArgs === 1,\n  }\n}\n\n/**\n * Creates a sparse array containing only the used arguments based on the\n * provided action info.\n */\nexport function omitUnusedArgs(\n  args: unknown[],\n  info: ServerReferenceInfo\n): unknown[] {\n  const filteredArgs = new Array(args.length)\n\n  for (let index = 0; index < args.length; index++) {\n    if (\n      (index < 6 && info.usedArgs[index]) ||\n      // This assumes that the server reference info byte has the restArgs bit\n      // set to 1 if there are more than 6 args.\n      (index >= 6 && info.hasRestArgs)\n    ) {\n      filteredArgs[index] = args[index]\n    }\n  }\n\n  return filteredArgs\n}\n","export type ActionRevalidationKind = 0 | 1 | 2\n\nexport const ActionDidNotRevalidate = 0\nexport const ActionDidRevalidateStaticAndDynamic = 1\nexport const ActionDidRevalidateDynamicOnly = 2\n","import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n  ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl, handleNavigationResult } from './navigate-reducer'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\nimport { getDeploymentId } from '../../../../shared/lib/deployment-id'\nimport {\n  navigateToSeededRoute,\n  navigate as navigateUsingSegmentCache,\n} from '../../segment-cache/navigation'\nimport type { NormalizedSearch } from '../../segment-cache/cache-key'\nimport {\n  ActionDidNotRevalidate,\n  ActionDidRevalidateDynamicOnly,\n  ActionDidRevalidateStaticAndDynamic,\n  type ActionRevalidationKind,\n} from '../../../../shared/lib/action-revalidation-kind'\nimport { isExternalURL } from '../../app-router-utils'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\n// TODO: Refactor to be a discriminated union. Or just get rid of it;\n// fetchServerAction only has one caller, no reason this intermediate type has\n// to exist.\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  revalidationKind: ActionRevalidationKind\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  actionFlightDataRenderedSearch: NormalizedSearch | undefined\n  actionFlightDataCouldBeIntercepted: boolean | undefined\n  isPrerender: boolean\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n\n  let revalidationKind: ActionRevalidationKind = ActionDidNotRevalidate\n  try {\n    const revalidationHeader = res.headers.get('x-action-revalidated')\n    if (revalidationHeader) {\n      const parsedKind = JSON.parse(revalidationHeader)\n      if (\n        parsedKind === ActionDidRevalidateStaticAndDynamic ||\n        parsedKind === ActionDidRevalidateDynamicOnly\n      ) {\n        revalidationKind = parsedKind\n      }\n    }\n  } catch {}\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n  let actionFlightDataRenderedSearch: FetchServerActionResult['actionFlightDataRenderedSearch']\n  let actionFlightDataCouldBeIntercepted: FetchServerActionResult['actionFlightDataCouldBeIntercepted']\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    const maybeFlightData = normalizeFlightData(response.f)\n    if (maybeFlightData !== '') {\n      actionFlightData = maybeFlightData\n      actionFlightDataRenderedSearch = response.q as NormalizedSearch\n      actionFlightDataCouldBeIntercepted = response.i\n    }\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n    actionFlightDataRenderedSearch = undefined\n    actionFlightDataCouldBeIntercepted = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    actionFlightDataRenderedSearch,\n    actionFlightDataCouldBeIntercepted,\n    redirectLocation,\n    redirectType,\n    revalidationKind,\n    isPrerender,\n  }\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      revalidationKind,\n      actionResult,\n      actionFlightData: flightData,\n      actionFlightDataRenderedSearch: flightDataRenderedSearch,\n      actionFlightDataCouldBeIntercepted: flightDataCouldBeIntercepted,\n      redirectLocation,\n      redirectType,\n    }) => {\n      if (revalidationKind !== ActionDidNotRevalidate) {\n        // Store whether this action triggered any revalidation\n        // The action queue will use this information to potentially\n        // trigger a refresh action if the action was discarded\n        // (ie, due to a navigation, before the action completed)\n        action.didRevalidate = true\n\n        // If there was a revalidation, evict the entire prefetch cache.\n        // TODO: Evict only segments with matching tags and/or paths.\n        if (revalidationKind === ActionDidRevalidateStaticAndDynamic) {\n          revalidateEntireCache(nextUrl, state.tree)\n        }\n      }\n\n      const pendingPush = redirectType !== RedirectType.replace\n      state.pushRef.pendingPush = pendingPush\n      mutable.pendingPush = pendingPush\n\n      if (redirectLocation !== undefined) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        const resolvedRedirectType = redirectType || RedirectType.push\n\n        if (isExternalURL(redirectLocation)) {\n          // External redirect. Triggers an MPA navigation.\n          const redirectHref = redirectLocation.href\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            resolvedRedirectType\n          )\n          reject(redirectError)\n          return handleExternalUrl(state, mutable, redirectHref, pendingPush)\n        } else {\n          // Internal redirect. Triggers an SPA navigation.\n          const redirectWithBasepath = createHrefFromUrl(\n            redirectLocation,\n            false\n          )\n          const redirectHref = hasBasePath(redirectWithBasepath)\n            ? removeBasePath(redirectWithBasepath)\n            : redirectWithBasepath\n          const redirectError = createRedirectErrorForAction(\n            redirectHref,\n            resolvedRedirectType\n          )\n          reject(redirectError)\n        }\n      } else {\n        // If there's no redirect, resolve the action with the result.\n        resolve(actionResult)\n      }\n\n      // Check if we can bail out without updating any state.\n      if (\n        // Did the action trigger a redirect?\n        redirectLocation === undefined &&\n        // Did the action revalidate any data?\n        revalidationKind === ActionDidNotRevalidate &&\n        // Did the server render new data?\n        flightData === undefined\n      ) {\n        // The action did not trigger any revalidations or redirects. No\n        // navigation is required.\n        return state\n      }\n\n      if (flightData === undefined && redirectLocation !== undefined) {\n        // The server redirected, but did not send any Flight data. This implies\n        // an external redirect.\n        // TODO: We should refactor the action response type to be more explicit\n        // about the various response types.\n        return handleExternalUrl(\n          state,\n          mutable,\n          redirectLocation.href,\n          pendingPush\n        )\n      }\n\n      if (typeof flightData === 'string') {\n        // If the flight data is just a string, something earlier in the\n        // response handling triggered an external redirect.\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      // The action triggered a navigation  either a redirect, a revalidation,\n      // or both.\n\n      // If there was no redirect, then the target URL is the same as the\n      // current URL.\n      const currentUrl = new URL(state.canonicalUrl, location.origin)\n      const redirectUrl =\n        redirectLocation !== undefined ? redirectLocation : currentUrl\n      const currentFlightRouterState = state.tree\n      const shouldScroll = true\n\n      // If the action triggered a revalidation of the cache, we should also\n      // refresh all the dynamic data.\n      const freshnessPolicy =\n        revalidationKind === ActionDidNotRevalidate\n          ? FreshnessPolicy.Default\n          : FreshnessPolicy.RefreshAll\n\n      // The server may have sent back new data. If so, we will perform a\n      // \"seeded\" navigation that uses the data from the response.\n      if (flightData !== undefined) {\n        const normalizedFlightData = flightData[0]\n        if (\n          normalizedFlightData !== undefined &&\n          // TODO: Currently the server always renders from the root in\n          // response to a Server Action. In the case of a normal redirect\n          // with no revalidation, it should skip over the shared layouts.\n          normalizedFlightData.isRootRender &&\n          flightDataRenderedSearch !== undefined &&\n          flightDataCouldBeIntercepted !== undefined\n        ) {\n          // The server sent back new route data as part of the response. We\n          // will use this to render the new page. If this happens to be only a\n          // subset of the data needed to render the new page, we'll initiate a\n          // new fetch, like we would for a normal navigation.\n          const redirectCanonicalUrl = createHrefFromUrl(redirectUrl)\n          const navigationSeed = {\n            tree: normalizedFlightData.tree,\n            renderedSearch: flightDataRenderedSearch,\n            data: normalizedFlightData.seedData,\n            head: normalizedFlightData.head,\n          }\n          const now = Date.now()\n          const result = navigateToSeededRoute(\n            now,\n            redirectUrl,\n            redirectCanonicalUrl,\n            navigationSeed,\n            currentUrl,\n            state.cache,\n            currentFlightRouterState,\n            freshnessPolicy,\n            nextUrl,\n            shouldScroll\n          )\n          return handleNavigationResult(\n            redirectUrl,\n            state,\n            mutable,\n            pendingPush,\n            result\n          )\n        }\n      }\n\n      // The server did not send back new data. We'll perform a regular, non-\n      // seeded navigation  effectively the same as <Link> or router.push().\n      const result = navigateUsingSegmentCache(\n        redirectUrl,\n        currentUrl,\n        state.cache,\n        currentFlightRouterState,\n        nextUrl,\n        freshnessPolicy,\n        shouldScroll,\n        mutable\n      )\n      return handleNavigationResult(\n        redirectUrl,\n        state,\n        mutable,\n        pendingPush,\n        result\n      )\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n\nfunction createRedirectErrorForAction(\n  redirectHref: string,\n  resolvedRedirectType: RedirectType\n) {\n  const redirectError = getRedirectError(redirectHref, resolvedRedirectType)\n  // We mark the error as handled because we don't want the redirect to be tried later by\n  // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n  // again, as it's run within an effect.\n  // We don't actually need the RedirectBoundary to do a router.push because we already\n  // have all the necessary RSC data to render the new page within a single roundtrip.\n  ;(redirectError as any).handled = true\n  return redirectError\n}\n","import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { createPrefetchURL } from '../app-router-utils'\nimport { createCacheKey } from './cache-key'\nimport { schedulePrefetchTask } from './scheduler'\nimport { PrefetchPriority, type PrefetchTaskFetchStrategy } from './types'\n\n/**\n * Entrypoint for prefetching a URL into the Segment Cache.\n * @param href - The URL to prefetch. Typically this will come from a <Link>,\n * or router.prefetch. It must be validated before we attempt to prefetch it.\n * @param nextUrl - A special header used by the server for interception routes.\n * Roughly corresponds to the current URL.\n * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n * was requested. This is only used when PPR is disabled.\n * @param fetchStrategy - Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n * @param onInvalidate - A callback that will be called when the prefetch cache\n * When called, it signals to the listener that the data associated with the\n * prefetch may have been invalidated from the cache. This is not a live\n * subscription  it's called at most once per `prefetch` call. The only\n * supported use case is to trigger a new prefetch inside the listener, if\n * desired. It also may be called even in cases where the associated data is\n * still cached. Prefetching is a poll-based (pull) operation, not an event-\n * based (push) one. Rather than subscribe to specific cache entries, you\n * occasionally poll the prefetch cache to check if anything is missing.\n */\nexport function prefetch(\n  href: string,\n  nextUrl: string | null,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  onInvalidate: null | (() => void)\n) {\n  const url = createPrefetchURL(href)\n  if (url === null) {\n    // This href should not be prefetched.\n    return\n  }\n  const cacheKey = createCacheKey(url.href, nextUrl)\n  schedulePrefetchTask(\n    cacheKey,\n    treeAtTimeOfPrefetch,\n    fetchStrategy,\n    PrefetchPriority.Default,\n    onInvalidate\n  )\n}\n","import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  type AppHistoryState,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache/types'\nimport { prefetch as prefetchWithSegmentCache } from './segment-cache/prefetch'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { isExternalURL } from './app-router-utils'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    }\n  } else {\n    // Check for refresh when pending is already null\n    // This handles the case where a discarded server action completes\n    // after the navigation has already finished and the queue is empty\n    if (actionQueue.needsRefresh) {\n      actionQueue.needsRefresh = false\n      actionQueue.dispatch({ type: ACTION_REFRESH }, setState)\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      // Check if the discarded server action revalidated data\n      if (\n        action.payload.type === ACTION_SERVER_ACTION &&\n        action.payload.didRevalidate\n      ) {\n        // The server action was discarded but it revalidated data,\n        // mark that we need to refresh after all actions complete\n        actionQueue.needsRefresh = true\n      }\n      // Still need to run remaining actions even for discarded actions\n      // to potentially trigger the refresh\n      runRemainingActions(actionQueue, setState)\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  historyState: AppHistoryState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    historyState,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch:\n    // Unlike the old implementation, the Segment Cache doesn't store its\n    // data in the router reducer state; it writes into a global mutable\n    // cache. So we don't need to dispatch an action.\n    (href: string, options?: PrefetchOptions) => {\n      const actionQueue = getAppRouterActionQueue()\n      const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n      // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n      // This will be possible when we update its API to not take a PrefetchKind.\n      let fetchStrategy: PrefetchTaskFetchStrategy\n      switch (prefetchKind) {\n        case PrefetchKind.AUTO: {\n          // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n          fetchStrategy = FetchStrategy.PPR\n          break\n        }\n        case PrefetchKind.FULL: {\n          fetchStrategy = FetchStrategy.Full\n          break\n        }\n        default: {\n          prefetchKind satisfies never\n          // Despite typescript thinking that this can't happen,\n          // we might get an unexpected value from user code.\n          // We don't know what they want, but we know they want a prefetch,\n          // so use the default.\n          fetchStrategy = FetchStrategy.PPR\n        }\n      }\n\n      prefetchWithSegmentCache(\n        href,\n        actionQueue.state.nextUrl,\n        actionQueue.state.tree,\n        fetchStrategy,\n        options?.onInvalidate ?? null\n      )\n    },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash","HTML_LIMITED_BOT_UA_RE","HTML_LIMITED_BOT_UA_RE_STRING","getBotType","isBot","HEADLESS_BROWSER_BOT_UA_RE","source","isDomBotUA","userAgent","test","isHtmlLimitedBotUA","undefined","ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind","isThenable","promise","then","dispatchAppRouterAction","useActionQueue","dispatch","action","Error","__DEV__","process","env","NODE_ENV","promisesWithDebugInfo","WeakMap","actionQueue","state","setState","React","useState","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","promiseWithDebugInfo","get","debugInfo","Promise","resolve","asyncState","push","_debugInfo","set","use","callServer","actionId","actionArgs","reject","startTransition","type","findSourceMapURL","basePath","__NEXT_ROUTER_BASEPATH","filename","startsWith","document","location","origin","includes","URL","searchParams","href","ensureLeadingSlash","path","normalizeAppPath","normalizeRscURL","route","split","reduce","segment","index","segments","isGroupSegment","length","replace","INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","find","m","interceptingRoute","marker","interceptedRoute","slice","concat","join","splitInterceptingRoute","matchSegment","existingSegment","computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segmentToPathname","normalizeSegments","acc","flightRouterState","Array","isArray","DEFAULT_SEGMENT_KEY","some","PAGE_SEGMENT_KEY","parallelRoutes","childrenPath","children","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll","handleMutable","isNotUndefined","mutable","shouldScroll","previousNextUrl","nextUrl","patchedTree","tree","canonicalUrl","renderedSearch","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","segmentPaths","cache","collectedDebugInfo","HEAD_REQUEST_KEY","ROOT_SEGMENT_REQUEST_KEY","appendSegmentRequestKeyPart","convertSegmentPathToStaticExportFilename","createSegmentRequestKeyPart","safeName","encodeToFilesystemAndURLSafeString","name","paramType","encodedName","parentRequestKey","parallelRouteKey","childRequestKeyPart","slotKey","simpleParamValueRegex","base64url","btoa","segmentPath","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","NEXT_REWRITTEN_QUERY_HEADER","rewrittenPath","NEXT_REWRITTEN_PATH_HEADER","pathnameParts","partIndex","map","s","encodeURIComponent","prefix","i","endsWith","paramValue","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","fromEntries","URLSearchParams","urlWithoutFlightParameters","delete","NEXT_RSC_UNION_QUERY","__NEXT_CONFIG_OUTPUT","paramCacheKey","result","createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","seedData","head","isHeadPartial","pathToSegment","isRootRender","fallbackInitialRSCPayload","renderedPathname","originalFlightDataPath","f","originalFlightRouterState","b","c","q","fillInFallbackFlightRouterState","G","S","filter","p","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","paramName","cacheKey","childPathnamePartsIndex","newChildren","childFlightRouterState","newState","flightSegmentPath","flightData","isHmrRefresh","JSON","stringify","stripClientOnlyDataFromFlightRouterState","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","childState","shouldPreserveRefreshMarker","Boolean","getAppBuildId","setAppBuildId","globalBuildId","buildId","djb2Hash","hexHash","str","char","charCodeAt","toString","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","uniqueCacheKey","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","existingSearch","rawQuery","pairs","pair","createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","__NEXT_REACT_DEBUG_CHANNEL","doMpaNavigation","isPageUnloading","window","addEventListener","options","RSC_HEADER","NEXT_HMR_REFRESH_HEADER","originalUrl","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","res","responseUrl","redirected","contentType","interception","postponed","NEXT_DID_POSTPONE_HEADER","staleTimeHeaderSeconds","NEXT_ROUTER_STALE_TIME_HEADER","staleTime","parseInt","isFlightResponse","RSC_CONTENT_TYPE_HEADER","ok","body","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","normalizedFlightData","couldBeIntercepted","prerendered","err","console","error","fetchPriority","signal","__NEXT_TEST_MODE","deploymentId","getDeploymentId","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","fetchUrl","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","rscResponse","status","requestHeaders","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","createRouterCacheKey","withoutSearchParameters","isNavigatingToNewRootLayout","nextTree","currentTreeSegment","nextTreeSegment","currentTreeChild","nextTreeChild","FreshnessPolicy","createInitialCacheNodeForHydration","isDeferredRsc","spawnDynamicRequests","startPPRNavigation","noop","navigatedAt","initialTree","seedHead","accumulation","separateRefreshUrls","task","createCacheNodeOnNavigation","node","oldUrl","oldCacheNode","oldRouterState","newRouterState","freshness","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","didFindRootLayout","parentNeedsDynamicRequest","parentRefreshUrl","updateCacheNodeOnNavigation","parentSegmentPath","parentParallelRouteKey","oldSegment","NOT_FOUND_SEGMENT_KEY","newRouterStateChildren","oldRouterStateChildren","seedDataChildren","prefetchDataChildren","childDidFindRootLayout","oldParallelRoutes","shouldDropSiblingCaches","shouldRefreshDynamicData","newParallelRoutes","Map","isLeafSegment","keys","newCacheNode","needsDynamicRequest","dropPrefetchRsc","reuseDynamicCacheNode","seedRsc","seedLoading","isSeedRscPartial","isSeedHeadPartial","readCacheNodeFromSeedData","prefetchRsc","prefetchLoading","isPrefetchRSCPartial","spawnNewCacheNode","refreshUrl","accumulateRefreshUrl","patchedRouterStateChildren","taskChildren","childNeedsDynamicRequest","dynamicRequestTreeChildren","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","seedDataChild","prefetchDataChild","newSegmentChild","seedHeadChild","prefetchHeadChild","isPrefetchHeadPartialChild","reuseActiveSegmentInDefaultSlot","newSegmentKeyChild","oldCacheNodeChild","taskChild","newCacheNodeChild","newSegmentMapChild","taskChildRoute","dynamicRequestTreeChild","dynamicRequestTree","patchRouterStateWithNewChildren","createDynamicRequestTree","DYNAMIC_STALETIME_MS","oldRsc","rsc","oldRscDidResolve","baseRouterState","clone","Set","add","reusedRouterState","oldRefreshMarker","existingCacheNode","cacheNode","loading","isPageSegment","createDeferredRsc","isHydration","previousNavigationDidMismatch","primaryUrl","freshnessPolicy","primaryRequestPromise","fetchMissingDynamicData","refreshRequestPromises","scopedDynamicRequestTree","voidPromise","finishNavigationTask","exitStatus","waitForRequestsToFinish","abortRemainingPendingTasks","isHardRetry","primaryRequestResult","dispatchRetryDueToTreeMismatch","seed","onFulfill","remainingCount","onReject","forEach","refreshRequestPromise","retryUrl","retryNextUrl","baseTree","retryAction","previousTree","mpa","convertServerPatchToFullTree","didReceiveUnknownParallelRoute","writeDynamicDataIntoNavigationTask","data","serverRouterState","dynamicData","dynamicHead","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","taskSegment","childDidReceiveUnknownParallelRoute","dynamicSegmentData","dynamicLoading","abortPendingCacheNode","childExitStatus","DEFERRED","Symbol","tag","pendingRsc","rej","responseDebugInfo","fulfilledRsc","rejectedRsc","reason","HasLoadingBoundary","FetchStrategy","NavigationResultTag","PrefetchPriority","deleteFromLru","lruPut","updateLruSize","didScheduleCleanup","lruSize","maxLruSize","prev","next","size","ensureCleanupIsScheduled","tail","newNodeSize","prevNodeSize","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","deleteMapEntry","requestIdleCallback","cb","setTimeout","Fallback","createCacheMap","deleteFromCacheMap","getFromCacheMap","isValueExpired","setInCacheMap","setSizeInCacheMap","Revalidation","cacheMap","parent","getOrInitialize","isRevalidation","entry","remainingKeys","previousKey","existingEntry","newEntry","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","staleAt","version","lazilyEvictIfNeeded","fallbackEntry","setMapEntryValue","dropRef","oldEntry","ref","parentMap","revalidatingEntry","appendLayoutVaryPath","clonePageVaryPathWithNewSearchParams","finalizeLayoutVaryPath","finalizeMetadataVaryPath","finalizePageVaryPath","getFulfilledRouteVaryPath","getRouteVaryPath","getSegmentVaryPathForRequest","varyPath","parentPath","varyPathPart","requestKey","layoutVaryPath","pageVaryPath","pageRequestKey","fetchStrategy","originalVaryPath","isPage","doesVaryOnSearchParams","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","newSearch","clonedVaryPath","createCacheKey","originalHref","cancelPrefetchTask","isPrefetchTaskDirty","pingPrefetchTask","reschedulePrefetchTask","schedulePrefetchTask","startRevalidationCooldown","scheduleMicrotask","queueMicrotask","fn","catch","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","clearTimeout","ensureWorkIsScheduled","treeAtTimeOfPrefetch","onInvalidate","cacheVersion","getCurrentCacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","heapDelete","Intent","heapResift","Background","Default","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","onPrefetchConnectionClosed","closed","Date","heapPeek","pingRoute","heapPop","background","readOrCreateRouteCacheEntry","pingRootRouteTree","keyWithoutSearch","routeWithoutSearch","EntryStatus","Empty","Pending","fetchRouteOnCacheMiss","Fulfilled","Rejected","blockedTasks","PPR","isPPREnabled","LoadingBoundary","pingStaticHead","pingSharedPartOfCacheComponentsTree","spawnedEntries","pingRuntimeHead","requestTree","pingRuntimePrefetches","fetchSegmentPrefetchesUsingDynamicRequest","diffRouteTreeAgainstCurrent","pingStaticSegmentData","readOrCreateSegmentCacheEntry","metadata","pingRouteTreeAndIncludeDynamicData","oldTree","newTree","oldTreeChildren","newTreeChildren","slots","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","hasRuntimePrefetch","childTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","SubtreeHasNoLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","convertRouteTreeToFlightRouterState","refetchMarkerContext","refetchMarker","upgradeToPendingSegment","segmentHasLoadingBoundary","SegmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","isPartial","canNewFetchStrategyProvideMoreContent","pingFullSegmentRevalidation","has","routeKey","fetchSegmentOnCacheMiss","pingPPRSegmentRevalidation","revalidatingSegment","readOrCreateRevalidatingSegmentEntry","upsertSegmentOnCompletion","pendingSegment","waitForSegmentCacheEntry","nonEmptyRevalidatingSegment","emptySegment","overwriteRevalidatingSegmentCacheEntry","fulfilled","upsertSegmentEntry","currentSegment","cachedSegment","compareQueuePriority","a","priorityDiff","phaseDiff","heap","heapSiftUp","first","last","pop","heapSiftDown","parentIndex","halfLength","leftIndex","left","rightIndex","right","parsePath","hashIndex","indexOf","queryIndex","hasQuery","substring","query","addPathPrefix","removeTrailingSlash","normalizePathTrailingSlash","__NEXT_MANUAL_TRAILING_SLASH","__NEXT_TRAILING_SLASH","addBasePath","required","__NEXT_MANUAL_CLIENT_BASE_PATH","createPrefetchURL","isExternalURL","navigator","_","IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","pingVisibleLinks","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","setOptimisticLinkStatus","prefetchable","prefetchableAndVisible","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","observe","coercePrefetchableUrl","reportErrorFn","reportError","router","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","unobserve","intersectionRatio","target","rescheduleLinkPrefetch","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","existingPrefetchTask","getCurrentAppRouterState","appRouterState","scheduleSegmentPrefetchTask","createPromiseWithResolvers","createDetachedSegmentCacheEntry","getStaleTimeMs","pingInvalidationListeners","readRouteCacheEntry","readSegmentCacheEntry","requestOptimisticRouteCacheEntry","revalidateEntireCache","staleTimeSeconds","Math","max","isOutputExportMode","MetadataOnlyRequestTree","routeCacheMap","segmentCacheMap","invalidationListeners","attachInvalidationListener","notifyInvalidationListener","tasks","readRevalidatingSegmentCacheEntry","pendingEntry","promiseWithResolvers","Infinity","requestedUrl","requestedSearch","urlWithoutSearchParams","routeWithNoSearchParams","createPrefetchRequestKey","canonicalUrlForRouteWithNoSearchParams","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","optimisticCanonicalUrl","optimisticRouteTree","createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","newRenderedSearch","clonedSlots","originalSlots","varyPathForRequest","candidateEntry","rejectedEntry","emptyEntry","pingBlockedTasks","fulfillRouteCacheEntry","metadataVaryPath","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","rootSegment","convertTreePrefetchToRouteTree","prefetch","partialVaryPath","prefetchSlots","childPrefetch","childParamName","childParamType","childServerSentParamKey","paramKey","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","childParamKey","childRequestKey","convertRootFlightRouterStateToRouteTree","convertFlightRouterStateToRouteTree","parentPartialVaryPath","childRouterState","routeTree","urlAfterRedirects","headResponse","method","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","varyHeader","routeIsPPREnabled","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","serverData","staleTimeMs","writeDynamicTreeResponseIntoCache","fulfilledVaryPath","normalizedRequestKey","requestUrl","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","isNaN","STATIC_STALETIME_MS","flightDatas","writeSeedDataIntoCache","fulfillEntrySpawnedByRuntimePrefetch","entriesOwnedByCurrentTask","childSeedData","ownedEntry","possiblyNewEntry","onStreamClose","totalByteLength","byteLength","staticUrl","routeDir","staticExportFilename","currentStrategy","newStrategy","navigate","navigateToSeededRoute","currentUrl","currentCacheNode","currentFlightRouterState","snapshot","readRenderSnapshotFromCache","prefetchFlightRouterState","prefetchSeedData","headSnapshot","readHeadSnapshotFromCache","newCanonicalUrl","navigateUsingPrefetchedRouteTree","optimisticRoute","Async","navigateDynamicallyWithNoPrefetch","navigationSeed","navigationTaskToResult","MPA","Success","childRouterStates","childSeedDatas","childResult","segmentEntry","promiseForFulfilledEntry","DynamicRequestTreeForEntireRoute","HistoryTraversal","Hydration","RefreshAll","HMRRefresh","promiseForDynamicServerResponse","newUrl","debugInfoFromResponse","baseData","treePatch","dataPatch","headPatch","convertServerPatchToFullTreeImpl","updatedParallelRouteKey","baseTreeChildren","baseSeedDataChildren","newSeedDataChildren","childBaseRouterState","childBaseSeedData","clonedTree","clonedSeedData","isEmptySeedDataPartial","generateSegmentsFromPatch","handleExternalUrl","handleNavigationResult","navigateReducer","Number","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","flightRouterPatch","asyncResult","isExternalUrl","navigateType","getElementById","navigateUsingSegmentCache","hasInterceptionRouteInCurrentTree","refreshDynamicData","refreshReducer","currentNextUrl","currentRouterState","nextUrlForRefresh","currentCanonicalUrl","serverPatchReducer","retryMpa","retrySeed","retryCanonicalUrl","restoreReducer","treeToRestore","historyState","restoredUrl","restoredCanonicalUrl","restoredNextUrl","hmrRefreshReducer","assignLocation","urlBase","pathHasPrefix","hasBasePath","removeBasePath","extractInfoFromServerReferenceId","omitUnusedArgs","id","infoByte","typeBit","argMask","restArgs","usedArgs","bitPosition","bit","hasRestArgs","args","info","filteredArgs","ActionDidNotRevalidate","ActionDidRevalidateDynamicOnly","ActionDidRevalidateStaticAndDynamic","serverActionReducer","fetchServerAction","temporaryReferences","createTemporaryReferenceSet","encodeReply","Accept","ACTION_HEADER","unrecognizedActionHeader","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","redirectHeader","_redirectType","redirectType","RedirectType","isPrerender","NEXT_IS_PRERENDER_HEADER","revalidationKind","revalidationHeader","parsedKind","parse","redirectLocation","isRscResponse","message","text","actionResult","actionFlightData","actionFlightDataRenderedSearch","actionFlightDataCouldBeIntercepted","maybeFlightData","flightDataRenderedSearch","flightDataCouldBeIntercepted","didRevalidate","resolvedRedirectType","redirectHref","redirectError","createRedirectErrorForAction","redirectWithBasepath","redirectUrl","redirectCanonicalUrl","e","getRedirectError","handled","reducer","clientReducer","serverReducer","_action","createMutableActionQueue","dispatchNavigateAction","dispatchTraverseAction","publicAppRouterInstance","runRemainingActions","runAction","needsRefresh","prevState","payload","handleResult","nextState","discarded","dispatchAction","resolvers","deferredPromise","newAction","globalActionQueue","initialState","instrumentationHooks","onRouterTransitionStart","getAppRouterActionQueue","getProfilingHookForOnNavigationStart","linkInstanceRef","__NEXT_APP_NAV_FAIL_HANDLING","__pendingUrl","locationSearch","back","history","forward","prefetchKind","kind","AUTO","FULL","prefetchWithSegmentCache","scroll","refresh","hmrRefresh"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60]}