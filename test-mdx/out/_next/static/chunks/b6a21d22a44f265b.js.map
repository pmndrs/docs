{"version":3,"sources":["turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/router/utils/disable-smooth-scroll.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/http-access-fallback/error-boundary.tsx","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/bfcache.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/layout-router.tsx","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/render-from-template-context.tsx","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/request/search-params.browser.prod.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/request/search-params.browser.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/request/params.browser.prod.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/request/params.browser.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/web/spec-extension/adapters/reflect.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/shared/lib/utils/reflect-utils.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/app-render/after-task-async-storage-instance.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/app-render/after-task-async-storage.external.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/request/utils.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/app-render/staged-rendering.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/request/search-params.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/app-render/dynamic-access-async-storage-instance.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/app-render/dynamic-access-async-storage.external.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/server/request/params.ts","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/client-page.tsx","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/client/components/client-segment.tsx","turbopack:///[project]/node_modules/.pnpm/next@16.1.3_@babel+core@7.28.6_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/next/src/lib/metadata/generate/icon-mark.tsx"],"sourcesContent":["import { warnOnce } from '../../utils/warn-once'\n\n/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */\nexport function disableSmoothScrollDuringRouteTransition(\n  fn: () => void,\n  options: { dontForceLayout?: boolean; onlyHashChange?: boolean } = {}\n) {\n  // if only the hash is changed, we don't need to disable smooth scrolling\n  // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n  if (options.onlyHashChange) {\n    fn()\n    return\n  }\n\n  const htmlElement = document.documentElement\n  const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth'\n\n  if (!hasDataAttribute) {\n    // Warn if smooth scrolling is detected but no data attribute is present\n    if (\n      process.env.NODE_ENV === 'development' &&\n      getComputedStyle(htmlElement).scrollBehavior === 'smooth'\n    ) {\n      warnOnce(\n        'Detected `scroll-behavior: smooth` on the `<html>` element. To disable smooth scrolling during route transitions, ' +\n          'add `data-scroll-behavior=\"smooth\"` to your <html> element. ' +\n          'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior'\n      )\n    }\n    // No smooth scrolling configured, run directly without style manipulation\n    fn()\n    return\n  }\n\n  // Proceed with temporarily disabling smooth scrolling\n  const existing = htmlElement.style.scrollBehavior\n  htmlElement.style.scrollBehavior = 'auto'\n  if (!options.dontForceLayout) {\n    // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n    // Otherwise it will not pickup the change in scrollBehavior\n    // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n    htmlElement.getClientRects()\n  }\n  fn()\n  htmlElement.style.scrollBehavior = existing\n}\n","'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  // TODO: Make this required once `React.createElement` understands that positional args go into children\n  children?: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n","import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport { useState } from 'react'\n\n// When the flag is disabled, only track the currently active tree\nconst MAX_BF_CACHE_ENTRIES = process.env.__NEXT_CACHE_COMPONENTS ? 3 : 1\n\nexport type RouterBFCacheEntry = {\n  tree: FlightRouterState\n  stateKey: string\n  // The entries form a linked list, sorted in order of most recently active.\n  next: RouterBFCacheEntry | null\n}\n\n/**\n * Keeps track of the most recent N trees (FlightRouterStates) that were active\n * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\n * tracks the last N param values that the router rendered for N.\n *\n * The result of this hook precisely determines the number and order of\n * trees that are rendered in parallel at their segment level.\n *\n * The purpose of this cache is to we can preserve the React and DOM state of\n * some number of inactive trees, by rendering them in an <Activity> boundary.\n * That means it would not make sense for the the lifetime of the cache to be\n * any longer than the lifetime of the React tree; e.g. if the hook were\n * unmounted, then the React tree would be, too. So, we use React state to\n * manage it.\n *\n * Note that we don't store the RSC data for the cache entries in this hook —\n * the data for inactive segments is stored in the parent CacheNode, which\n * *does* have a longer lifetime than the React tree. This hook only determines\n * which of those trees should have their *state* preserved, by <Activity>.\n */\nexport function useRouterBFCache(\n  activeTree: FlightRouterState,\n  activeStateKey: string\n): RouterBFCacheEntry {\n  // The currently active entry. The entries form a linked list, sorted in\n  // order of most recently active. This allows us to reuse parts of the list\n  // without cloning, unless there's a reordering or removal.\n  // TODO: Once we start tracking back/forward history at each route level,\n  // we should use the history order instead. In other words, when traversing\n  // to an existing entry as a result of a popstate event, we should maintain\n  // the existing order instead of moving it to the front of the list. I think\n  // an initial implementation of this could be to pass an incrementing id\n  // to history.pushState/replaceState, then use that here for ordering.\n  const [prevActiveEntry, setPrevActiveEntry] = useState<RouterBFCacheEntry>(\n    () => {\n      const initialEntry: RouterBFCacheEntry = {\n        tree: activeTree,\n        stateKey: activeStateKey,\n        next: null,\n      }\n      return initialEntry\n    }\n  )\n\n  if (prevActiveEntry.tree === activeTree) {\n    // Fast path. The active tree hasn't changed, so we can reuse the\n    // existing state.\n    return prevActiveEntry\n  }\n\n  // The route tree changed. Note that this doesn't mean that the tree changed\n  // *at this level* — the change may be due to a child route. Either way, we\n  // need to either add or update the router tree in the bfcache.\n  //\n  // The rest of the code looks more complicated than it actually is because we\n  // can't mutate the state in place; we have to copy-on-write.\n\n  // Create a new entry for the active cache key. This is the head of the new\n  // linked list.\n  const newActiveEntry: RouterBFCacheEntry = {\n    tree: activeTree,\n    stateKey: activeStateKey,\n    next: null,\n  }\n\n  // We need to append the old list onto the new list. If the head of the new\n  // list was already present in the cache, then we'll need to clone everything\n  // that came before it. Then we can reuse the rest.\n  let n = 1\n  let oldEntry: RouterBFCacheEntry | null = prevActiveEntry\n  let clonedEntry: RouterBFCacheEntry = newActiveEntry\n  while (oldEntry !== null && n < MAX_BF_CACHE_ENTRIES) {\n    if (oldEntry.stateKey === activeStateKey) {\n      // Fast path. This entry in the old list that corresponds to the key that\n      // is now active. We've already placed a clone of this entry at the front\n      // of the new list. We can reuse the rest of the old list without cloning.\n      // NOTE: We don't need to worry about eviction in this case because we\n      // haven't increased the size of the cache, and we assume the max size\n      // is constant across renders. If we were to change it to a dynamic limit,\n      // then the implementation would need to account for that.\n      clonedEntry.next = oldEntry.next\n      break\n    } else {\n      // Clone the entry and append it to the list.\n      n++\n      const entry: RouterBFCacheEntry = {\n        tree: oldEntry.tree,\n        stateKey: oldEntry.stateKey,\n        next: null,\n      }\n      clonedEntry.next = entry\n      clonedEntry = entry\n    }\n    oldEntry = oldEntry.next\n  }\n\n  setPrevActiveEntry(newActiveEntry)\n  return newActiveEntry\n}\n","'use client'\n\nimport type { CacheNode } from '../../shared/lib/app-router-types'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../shared/lib/app-router-types'\nimport type { ErrorComponent } from './error-boundary'\nimport type { FocusAndScrollRef } from './router-reducer/router-reducer-types'\n\nimport React, {\n  Activity,\n  useContext,\n  use,\n  Suspense,\n  useDeferredValue,\n  type JSX,\n  type ActivityProps,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n  TemplateContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { ErrorBoundary } from './error-boundary'\nimport { matchSegment } from './match-segments'\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key'\nimport { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport {\n  NavigationPromisesContext,\n  type NavigationPromises,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { getParamValueFromCacheKey } from '../route-params'\nimport type { Params } from '../../server/request/params'\nimport { isDeferredRsc } from './router-reducer/ppr-navigations'\n\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n  ReactDOM as any\n).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\nfunction findDOMNode(\n  instance: React.ReactInstance | null | undefined\n): Element | Text | null {\n  // Tree-shake for server bundle\n  if (typeof window === 'undefined') return null\n\n  // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n  // We need to lazily reference it.\n  const internal_reactDOMfindDOMNode =\n    __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode\n  return internal_reactDOMfindDOMNode(instance)\n}\n\nconst rectProperties = [\n  'bottom',\n  'height',\n  'left',\n  'right',\n  'top',\n  'width',\n  'x',\n  'y',\n] as const\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */\nfunction shouldSkipElement(element: HTMLElement) {\n  // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n  // and will result in a situation we bail on scroll because of something like a fixed nav,\n  // even though the actual page content is offscreen\n  if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {\n    return true\n  }\n\n  // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n  // because `offsetParent` doesn't consider document/body\n  const rect = element.getBoundingClientRect()\n  return rectProperties.every((item) => rect[item] === 0)\n}\n\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */\nfunction topOfElementInViewport(element: HTMLElement, viewportHeight: number) {\n  const rect = element.getBoundingClientRect()\n  return rect.top >= 0 && rect.top <= viewportHeight\n}\n\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */\nfunction getHashFragmentDomNode(hashFragment: string) {\n  // If the hash fragment is `top` the page has to scroll to the top of the page.\n  if (hashFragment === 'top') {\n    return document.body\n  }\n\n  // If the hash fragment is an id, the page has to scroll to the element with that id.\n  return (\n    document.getElementById(hashFragment) ??\n    // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0]\n  )\n}\ninterface ScrollAndFocusHandlerProps {\n  focusAndScrollRef: FocusAndScrollRef\n  children: React.ReactNode\n  segmentPath: FlightSegmentPath\n}\nclass InnerScrollAndFocusHandler extends React.Component<ScrollAndFocusHandlerProps> {\n  handlePotentialScroll = () => {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    const { focusAndScrollRef, segmentPath } = this.props\n\n    if (focusAndScrollRef.apply) {\n      // segmentPaths is an array of segment paths that should be scrolled to\n      // if the current segment path is not in the array, the scroll is not applied\n      // unless the array is empty, in which case the scroll is always applied\n      if (\n        focusAndScrollRef.segmentPaths.length !== 0 &&\n        !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>\n          segmentPath.every((segment, index) =>\n            matchSegment(segment, scrollRefSegmentPath[index])\n          )\n        )\n      ) {\n        return\n      }\n\n      let domNode:\n        | ReturnType<typeof getHashFragmentDomNode>\n        | ReturnType<typeof findDOMNode> = null\n      const hashFragment = focusAndScrollRef.hashFragment\n\n      if (hashFragment) {\n        domNode = getHashFragmentDomNode(hashFragment)\n      }\n\n      // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n      // This already caused a bug where the first child was a <link/> in head.\n      if (!domNode) {\n        domNode = findDOMNode(this)\n      }\n\n      // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n      if (!(domNode instanceof Element)) {\n        return\n      }\n\n      // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n      // If the element is skipped, try to select the next sibling and try again.\n      while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (domNode.parentElement?.localName === 'head') {\n            // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n            // This is always a bug in Next.js and caused by React hoisting metadata.\n            // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n          }\n        }\n\n        // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n        if (domNode.nextElementSibling === null) {\n          return\n        }\n        domNode = domNode.nextElementSibling\n      }\n\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false\n      focusAndScrollRef.hashFragment = null\n      focusAndScrollRef.segmentPaths = []\n\n      disableSmoothScrollDuringRouteTransition(\n        () => {\n          // In case of hash scroll, we only need to scroll the element into view\n          if (hashFragment) {\n            ;(domNode as HTMLElement).scrollIntoView()\n\n            return\n          }\n          // Store the current viewport height because reading `clientHeight` causes a reflow,\n          // and it won't change during this function.\n          const htmlElement = document.documentElement\n          const viewportHeight = htmlElement.clientHeight\n\n          // If the element's top edge is already in the viewport, exit early.\n          if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            return\n          }\n\n          // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n          // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n          // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n          // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n          htmlElement.scrollTop = 0\n\n          // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n          if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            // Scroll into view doesn't scroll horizontally by default when not needed\n            ;(domNode as HTMLElement).scrollIntoView()\n          }\n        },\n        {\n          // We will force layout by querying domNode position\n          dontForceLayout: true,\n          onlyHashChange: focusAndScrollRef.onlyHashChange,\n        }\n      )\n\n      // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\n      focusAndScrollRef.onlyHashChange = false\n\n      // Set focus on the element\n      domNode.focus()\n    }\n  }\n\n  componentDidMount() {\n    this.handlePotentialScroll()\n  }\n\n  componentDidUpdate() {\n    // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n    if (this.props.focusAndScrollRef.apply) {\n      this.handlePotentialScroll()\n    }\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nfunction ScrollAndFocusHandler({\n  segmentPath,\n  children,\n}: {\n  segmentPath: FlightSegmentPath\n  children: React.ReactNode\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  return (\n    <InnerScrollAndFocusHandler\n      segmentPath={segmentPath}\n      focusAndScrollRef={context.focusAndScrollRef}\n    >\n      {children}\n    </InnerScrollAndFocusHandler>\n  )\n}\n\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */\nfunction InnerLayoutRouter({\n  tree,\n  segmentPath,\n  debugNameContext,\n  cacheNode: maybeCacheNode,\n  params,\n  url,\n  isActive,\n}: {\n  tree: FlightRouterState\n  segmentPath: FlightSegmentPath\n  debugNameContext: string\n  cacheNode: CacheNode | null\n  params: Params\n  url: string\n  isActive: boolean\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  const parentNavPromises = useContext(NavigationPromisesContext)\n\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  const cacheNode =\n    maybeCacheNode !== null\n      ? maybeCacheNode\n      : // This segment is not in the cache. Suspend indefinitely.\n        //\n        // This should only be reachable for inactive/hidden segments, during\n        // prerendering The active segment should always be consistent with the\n        // CacheNode tree. Regardless, if we don't have a matching CacheNode, we\n        // must suspend rather than render nothing, to prevent showing an\n        // inconsistent route.\n\n        (use(unresolvedThenable) as never)\n\n  // `rsc` represents the renderable node for this segment.\n\n  // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n  // We should use that on initial render instead of `rsc`. Then we'll switch\n  // to `rsc` when the dynamic response streams in.\n  //\n  // If no prefetch data is available, then we go straight to rendering `rsc`.\n  const resolvedPrefetchRsc =\n    cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)\n\n  // `rsc` is either a React node or a promise for a React node, except we\n  // special case `null` to represent that this segment's data is missing. If\n  // it's a promise, we need to unwrap it so we can determine whether or not the\n  // data is missing.\n  let resolvedRsc: React.ReactNode\n  if (isDeferredRsc(rsc)) {\n    const unwrappedRsc = use(rsc)\n    if (unwrappedRsc === null) {\n      // If the promise was resolved to `null`, it means the data for this\n      // segment was not returned by the server. Suspend indefinitely. When this\n      // happens, the router is responsible for triggering a new state update to\n      // un-suspend this segment.\n      use(unresolvedThenable) as never\n    }\n    resolvedRsc = unwrappedRsc\n  } else {\n    // This is not a deferred RSC promise. Don't need to unwrap it.\n    if (rsc === null) {\n      use(unresolvedThenable) as never\n    }\n    resolvedRsc = rsc\n  }\n\n  // In dev, we create a NavigationPromisesContext containing the instrumented promises that provide\n  // `useSelectedLayoutSegment` and `useSelectedLayoutSegments`.\n  // Promises are cached outside of render to survive suspense retries.\n  let navigationPromises: NavigationPromises | null = null\n  if (process.env.NODE_ENV !== 'production') {\n    const { createNestedLayoutNavigationPromises } =\n      require('./navigation-devtools') as typeof import('./navigation-devtools')\n\n    navigationPromises = createNestedLayoutNavigationPromises(\n      tree,\n      parentNavPromises\n    )\n  }\n\n  let children = resolvedRsc\n\n  if (navigationPromises) {\n    children = (\n      <NavigationPromisesContext.Provider value={navigationPromises}>\n        {resolvedRsc}\n      </NavigationPromisesContext.Provider>\n    )\n  }\n\n  children = (\n    // The layout router context narrows down tree and childNodes at each level.\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: tree,\n        parentCacheNode: cacheNode,\n        parentSegmentPath: segmentPath,\n        parentParams: params,\n        debugNameContext: debugNameContext,\n\n        // TODO-APP: overriding of url for parallel routes\n        url: url,\n        isActive: isActive,\n      }}\n    >\n      {children}\n    </LayoutRouterContext.Provider>\n  )\n\n  return children\n}\n\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\nfunction LoadingBoundary({\n  name,\n  loading,\n  children,\n}: {\n  name: ActivityProps['name']\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  children: React.ReactNode\n}): JSX.Element {\n  // If loading is a promise, unwrap it. This happens in cases where we haven't\n  // yet received the loading data from the server — which includes whether or\n  // not this layout has a loading component at all.\n  //\n  // It's OK to suspend here instead of inside the fallback because this\n  // promise will resolve simultaneously with the data for the segment itself.\n  // So it will never suspend for longer than it would have if we didn't use\n  // a Suspense fallback at all.\n  let loadingModuleData\n  if (\n    typeof loading === 'object' &&\n    loading !== null &&\n    typeof (loading as any).then === 'function'\n  ) {\n    const promiseForLoading = loading as Promise<LoadingModuleData>\n    loadingModuleData = use(promiseForLoading)\n  } else {\n    loadingModuleData = loading as LoadingModuleData\n  }\n\n  if (loadingModuleData) {\n    const loadingRsc = loadingModuleData[0]\n    const loadingStyles = loadingModuleData[1]\n    const loadingScripts = loadingModuleData[2]\n    return (\n      <Suspense\n        name={name}\n        fallback={\n          <>\n            {loadingStyles}\n            {loadingScripts}\n            {loadingRsc}\n          </>\n        }\n      >\n        {children}\n      </Suspense>\n    )\n  }\n\n  return <>{children}</>\n}\n\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */\nexport default function OuterLayoutRouter({\n  parallelRouterKey,\n  error,\n  errorStyles,\n  errorScripts,\n  templateStyles,\n  templateScripts,\n  template,\n  notFound,\n  forbidden,\n  unauthorized,\n  segmentViewBoundaries,\n}: {\n  parallelRouterKey: string\n  error: ErrorComponent | undefined\n  errorStyles: React.ReactNode | undefined\n  errorScripts: React.ReactNode | undefined\n  templateStyles: React.ReactNode | undefined\n  templateScripts: React.ReactNode | undefined\n  template: React.ReactNode\n  notFound: React.ReactNode | undefined\n  forbidden: React.ReactNode | undefined\n  unauthorized: React.ReactNode | undefined\n  segmentViewBoundaries?: React.ReactNode\n}) {\n  const context = useContext(LayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted')\n  }\n\n  const {\n    parentTree,\n    parentCacheNode,\n    parentSegmentPath,\n    parentParams,\n    url,\n    isActive,\n    debugNameContext,\n  } = context\n\n  // Get the CacheNode for this segment by reading it from the parent segment's\n  // child map.\n  const parentParallelRoutes = parentCacheNode.parallelRoutes\n  let segmentMap = parentParallelRoutes.get(parallelRouterKey)\n  // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n  if (!segmentMap) {\n    segmentMap = new Map()\n    parentParallelRoutes.set(parallelRouterKey, segmentMap)\n  }\n  const parentTreeSegment = parentTree[0]\n  const segmentPath =\n    parentSegmentPath === null\n      ? // TODO: The root segment value is currently omitted from the segment\n        // path. This has led to a bunch of special cases scattered throughout\n        // the code. We should clean this up.\n        [parallelRouterKey]\n      : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])\n\n  // The \"state\" key of a segment is the one passed to React — it represents the\n  // identity of the UI tree. Whenever the state key changes, the tree is\n  // recreated and the state is reset. In the App Router model, search params do\n  // not cause state to be lost, so two segments with the same segment path but\n  // different search params should have the same state key.\n  //\n  // The \"cache\" key of a segment, however, *does* include the search params, if\n  // it's possible that the segment accessed the search params on the server.\n  // (This only applies to page segments; layout segments cannot access search\n  // params on the server.)\n  const activeTree = parentTree[1][parallelRouterKey]\n  if (activeTree === undefined) {\n    // Could not find a matching segment. The client tree is inconsistent with\n    // the server tree. Suspend indefinitely; the router will have already\n    // detected the inconsistency when handling the server response, and\n    // triggered a refresh of the page to recover.\n    use(unresolvedThenable) as never\n  }\n\n  const activeSegment = activeTree[0]\n  const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n\n  // At each level of the route tree, not only do we render the currently\n  // active segment — we also render the last N segments that were active at\n  // this level inside a hidden <Activity> boundary, to preserve their state\n  // if or when the user navigates to them again.\n  //\n  // bfcacheEntry is a linked list of FlightRouterStates.\n  let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(\n    activeTree,\n    activeStateKey\n  )\n  let children: Array<React.ReactNode> = []\n  do {\n    const tree = bfcacheEntry.tree\n    const stateKey = bfcacheEntry.stateKey\n    const segment = tree[0]\n    const cacheKey = createRouterCacheKey(segment)\n\n    // Read segment path from the parallel router cache node.\n    const cacheNode = segmentMap.get(cacheKey) ?? null\n\n    /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */\n\n    let segmentBoundaryTriggerNode: React.ReactNode = null\n    let segmentViewStateNode: React.ReactNode = null\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentBoundaryTriggerNode, SegmentViewStateNode } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      const pagePrefix = normalizeAppPath(url)\n      segmentViewStateNode = (\n        <SegmentViewStateNode key={pagePrefix} page={pagePrefix} />\n      )\n\n      segmentBoundaryTriggerNode = (\n        <>\n          <SegmentBoundaryTriggerNode />\n        </>\n      )\n    }\n\n    let params = parentParams\n    if (Array.isArray(segment)) {\n      // This segment contains a route param. Accumulate these as we traverse\n      // down the router tree. The result represents the set of params that\n      // the layout/page components are permitted to access below this point.\n      const paramName = segment[0]\n      const paramCacheKey = segment[1]\n      const paramType = segment[2]\n      const paramValue = getParamValueFromCacheKey(paramCacheKey, paramType)\n      if (paramValue !== null) {\n        params = {\n          ...parentParams,\n          [paramName]: paramValue,\n        }\n      }\n    }\n\n    const debugName = getBoundaryDebugNameFromSegment(segment)\n    // `debugNameContext` represents the nearest non-\"virtual\" parent segment.\n    // `getBoundaryDebugNameFromSegment` returns undefined for virtual segments.\n    // So if `debugName` is undefined, the context is passed through unchanged.\n    const childDebugNameContext = debugName ?? debugNameContext\n\n    // In practical terms, clicking this name in the Suspense DevTools\n    // should select the child slots of that layout.\n    //\n    // So the name we apply to the Activity boundary is actually based on\n    // the nearest parent segments.\n    //\n    // We skip over \"virtual\" parents, i.e. ones inserted by Next.js that\n    // don't correspond to application-defined code.\n    const isVirtual = debugName === undefined\n    const debugNameToDisplay = isVirtual ? undefined : debugNameContext\n\n    // TODO: The loading module data for a segment is stored on the parent, then\n    // applied to each of that parent segment's parallel route slots. In the\n    // simple case where there's only one parallel route (the `children` slot),\n    // this is no different from if the loading module data where stored on the\n    // child directly. But I'm not sure this actually makes sense when there are\n    // multiple parallel routes. It's not a huge issue because you always have\n    // the option to define a narrower loading boundary for a particular slot. But\n    // this sort of smells like an implementation accident to me.\n    const loadingModuleData = parentCacheNode.loading\n    let child = (\n      <TemplateContext.Provider\n        key={stateKey}\n        value={\n          <ScrollAndFocusHandler segmentPath={segmentPath}>\n            <ErrorBoundary\n              errorComponent={error}\n              errorStyles={errorStyles}\n              errorScripts={errorScripts}\n            >\n              <LoadingBoundary\n                name={debugNameToDisplay}\n                loading={loadingModuleData}\n              >\n                <HTTPAccessFallbackBoundary\n                  notFound={notFound}\n                  forbidden={forbidden}\n                  unauthorized={unauthorized}\n                >\n                  <RedirectBoundary>\n                    <InnerLayoutRouter\n                      url={url}\n                      tree={tree}\n                      params={params}\n                      cacheNode={cacheNode}\n                      segmentPath={segmentPath}\n                      debugNameContext={childDebugNameContext}\n                      isActive={isActive && stateKey === activeStateKey}\n                    />\n                    {segmentBoundaryTriggerNode}\n                  </RedirectBoundary>\n                </HTTPAccessFallbackBoundary>\n              </LoadingBoundary>\n            </ErrorBoundary>\n            {segmentViewStateNode}\n          </ScrollAndFocusHandler>\n        }\n      >\n        {templateStyles}\n        {templateScripts}\n        {template}\n      </TemplateContext.Provider>\n    )\n\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentStateProvider } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      child = (\n        <SegmentStateProvider key={stateKey}>\n          {child}\n          {segmentViewBoundaries}\n        </SegmentStateProvider>\n      )\n    }\n\n    if (process.env.__NEXT_CACHE_COMPONENTS) {\n      child = (\n        <Activity\n          name={debugNameToDisplay}\n          key={stateKey}\n          mode={stateKey === activeStateKey ? 'visible' : 'hidden'}\n        >\n          {child}\n        </Activity>\n      )\n    }\n\n    children.push(child)\n\n    bfcacheEntry = bfcacheEntry.next\n  } while (bfcacheEntry !== null)\n\n  return children\n}\n\nfunction getBoundaryDebugNameFromSegment(segment: Segment): string | undefined {\n  if (segment === '/') {\n    // Reached the root\n    return '/'\n  }\n  if (typeof segment === 'string') {\n    if (isVirtualLayout(segment)) {\n      return undefined\n    } else {\n      return segment + '/'\n    }\n  }\n  const paramCacheKey = segment[1]\n  return paramCacheKey + '/'\n}\n\nfunction isVirtualLayout(segment: string): boolean {\n  return (\n    // This is inserted by the loader. We should consider encoding these\n    // in a more special way instead of checking the name, to distinguish them\n    // from app-defined groups.\n    segment === '(slot)'\n  )\n}\n","'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n","import type { SearchParams } from '../../server/request/search-params'\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nfunction makeUntrackedSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  return promise\n}\n\nexport function createRenderSearchParamsFromClient(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  return makeUntrackedSearchParams(underlyingSearchParams)\n}\n","export const createRenderSearchParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (\n        require('./search-params.browser.dev') as typeof import('./search-params.browser.dev')\n      ).createRenderSearchParamsFromClient\n    : (\n        require('./search-params.browser.prod') as typeof import('./search-params.browser.prod')\n      ).createRenderSearchParamsFromClient\n","import type { Params } from '../../server/request/params'\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nexport function createRenderParamsFromClient(\n  clientParams: Params\n): Promise<Params> {\n  return makeUntrackedParams(clientParams)\n}\n","export const createRenderParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (require('./params.browser.dev') as typeof import('./params.browser.dev'))\n        .createRenderParamsFromClient\n    : (\n        require('./params.browser.prod') as typeof import('./params.browser.prod')\n      ).createRenderParamsFromClient\n","export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n","import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n","// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`\n// even if this would have been fine too `searchParams.ಠ_ಠ`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  'status',\n  // 'value',\n  // 'error',\n\n  // React introspection\n  'displayName',\n  '_debugInfo',\n\n  // Common tested properties\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n","import type { AfterTaskAsyncStorage } from './after-task-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const afterTaskAsyncStorageInstance: AfterTaskAsyncStorage =\n  createAsyncLocalStorage()\n","import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { afterTaskAsyncStorageInstance as afterTaskAsyncStorage } from './after-task-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { WorkUnitStore } from './work-unit-async-storage.external'\n\nexport interface AfterTaskStore {\n  /** The phase in which the topmost `after` was called.\n   *\n   * NOTE: Can be undefined when running `generateStaticParams`,\n   * where we only have a `workStore`, no `workUnitStore`.\n   */\n  readonly rootTaskSpawnPhase: WorkUnitStore['phase'] | undefined\n}\n\nexport type AfterTaskAsyncStorage = AsyncLocalStorage<AfterTaskStore>\n\nexport { afterTaskAsyncStorage }\n","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n\nexport enum RenderStage {\n  Before = 1,\n  Static = 2,\n  Runtime = 3,\n  Dynamic = 4,\n  Abandoned = 5,\n}\n\nexport type NonStaticRenderStage = RenderStage.Runtime | RenderStage.Dynamic\n\nexport class StagedRenderingController {\n  currentStage: RenderStage = RenderStage.Before\n\n  staticInterruptReason: Error | null = null\n  runtimeInterruptReason: Error | null = null\n  staticStageEndTime: number = Infinity\n  runtimeStageEndTime: number = Infinity\n\n  private runtimeStageListeners: Array<() => void> = []\n  private dynamicStageListeners: Array<() => void> = []\n\n  private runtimeStagePromise = createPromiseWithResolvers<void>()\n  private dynamicStagePromise = createPromiseWithResolvers<void>()\n\n  private mayAbandon: boolean = false\n\n  constructor(\n    private abortSignal: AbortSignal | null = null,\n    private hasRuntimePrefetch: boolean\n  ) {\n    if (abortSignal) {\n      abortSignal.addEventListener(\n        'abort',\n        () => {\n          const { reason } = abortSignal\n          if (this.currentStage < RenderStage.Runtime) {\n            this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.runtimeStagePromise.reject(reason)\n          }\n          if (\n            this.currentStage < RenderStage.Dynamic ||\n            this.currentStage === RenderStage.Abandoned\n          ) {\n            this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.dynamicStagePromise.reject(reason)\n          }\n        },\n        { once: true }\n      )\n\n      this.mayAbandon = true\n    }\n  }\n\n  onStage(stage: NonStaticRenderStage, callback: () => void) {\n    if (this.currentStage >= stage) {\n      callback()\n    } else if (stage === RenderStage.Runtime) {\n      this.runtimeStageListeners.push(callback)\n    } else if (stage === RenderStage.Dynamic) {\n      this.dynamicStageListeners.push(callback)\n    } else {\n      // This should never happen\n      throw new InvariantError(`Invalid render stage: ${stage}`)\n    }\n  }\n\n  canSyncInterrupt() {\n    // If we haven't started the render yet, it can't be interrupted.\n    if (this.currentStage === RenderStage.Before) {\n      return false\n    }\n\n    const boundaryStage = this.hasRuntimePrefetch\n      ? RenderStage.Dynamic\n      : RenderStage.Runtime\n    return this.currentStage < boundaryStage\n  }\n\n  syncInterruptCurrentStageWithReason(reason: Error) {\n    if (this.currentStage === RenderStage.Before) {\n      return\n    }\n\n    // If Sync IO occurs during the initial (abandonable) render, we'll retry it,\n    // so we want a slightly different flow.\n    // See the implementation of `abandonRenderImpl` for more explanation.\n    if (this.mayAbandon) {\n      return this.abandonRenderImpl()\n    }\n\n    // If we're in the final render, we cannot abandon it. We need to advance to the Dynamic stage\n    // and capture the interruption reason.\n    switch (this.currentStage) {\n      case RenderStage.Static: {\n        this.staticInterruptReason = reason\n        this.advanceStage(RenderStage.Dynamic)\n        return\n      }\n      case RenderStage.Runtime: {\n        // We only error for Sync IO in the runtime stage if the route\n        // is configured to use runtime prefetching.\n        // We do this to reflect the fact that during a runtime prefetch,\n        // Sync IO aborts aborts the render.\n        // Note that `canSyncInterrupt` should prevent us from getting here at all\n        // if runtime prefetching isn't enabled.\n        if (this.hasRuntimePrefetch) {\n          this.runtimeInterruptReason = reason\n          this.advanceStage(RenderStage.Dynamic)\n        }\n        return\n      }\n      case RenderStage.Dynamic:\n      case RenderStage.Abandoned:\n      default:\n    }\n  }\n\n  getStaticInterruptReason() {\n    return this.staticInterruptReason\n  }\n\n  getRuntimeInterruptReason() {\n    return this.runtimeInterruptReason\n  }\n\n  getStaticStageEndTime() {\n    return this.staticStageEndTime\n  }\n\n  getRuntimeStageEndTime() {\n    return this.runtimeStageEndTime\n  }\n\n  abandonRender() {\n    if (!this.mayAbandon) {\n      throw new InvariantError(\n        '`abandonRender` called on a stage controller that cannot be abandoned.'\n      )\n    }\n\n    this.abandonRenderImpl()\n  }\n\n  private abandonRenderImpl() {\n    // In staged rendering, only the initial render is abandonable.\n    // We can abandon the initial render if\n    //   1. We notice a cache miss, and need to wait for caches to fill\n    //   2. A sync IO error occurs, and the render should be interrupted\n    //      (this might be a lazy intitialization of a module,\n    //       so we still want to restart in this case and see if it still occurs)\n    // In either case, we'll be doing another render after this one,\n    // so we only want to unblock the Runtime stage, not Dynamic, because\n    // unblocking the dynamic stage would likely lead to wasted (uncached) IO.\n    const { currentStage } = this\n    switch (currentStage) {\n      case RenderStage.Static: {\n        this.currentStage = RenderStage.Abandoned\n        this.resolveRuntimeStage()\n        return\n      }\n      case RenderStage.Runtime: {\n        this.currentStage = RenderStage.Abandoned\n        return\n      }\n      case RenderStage.Dynamic:\n      case RenderStage.Before:\n      case RenderStage.Abandoned:\n        break\n      default: {\n        currentStage satisfies never\n      }\n    }\n  }\n\n  advanceStage(\n    stage: RenderStage.Static | RenderStage.Runtime | RenderStage.Dynamic\n  ) {\n    // If we're already at the target stage or beyond, do nothing.\n    // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n    if (stage <= this.currentStage) {\n      return\n    }\n\n    let currentStage = this.currentStage\n    this.currentStage = stage\n\n    if (currentStage < RenderStage.Runtime && stage >= RenderStage.Runtime) {\n      this.staticStageEndTime = performance.now() + performance.timeOrigin\n      this.resolveRuntimeStage()\n    }\n    if (currentStage < RenderStage.Dynamic && stage >= RenderStage.Dynamic) {\n      this.runtimeStageEndTime = performance.now() + performance.timeOrigin\n      this.resolveDynamicStage()\n      return\n    }\n  }\n\n  /** Fire the `onStage` listeners for the runtime stage and unblock any promises waiting for it. */\n  private resolveRuntimeStage() {\n    const runtimeListeners = this.runtimeStageListeners\n    for (let i = 0; i < runtimeListeners.length; i++) {\n      runtimeListeners[i]()\n    }\n    runtimeListeners.length = 0\n    this.runtimeStagePromise.resolve()\n  }\n\n  /** Fire the `onStage` listeners for the dynamic stage and unblock any promises waiting for it. */\n  private resolveDynamicStage() {\n    const dynamicListeners = this.dynamicStageListeners\n    for (let i = 0; i < dynamicListeners.length; i++) {\n      dynamicListeners[i]()\n    }\n    dynamicListeners.length = 0\n    this.dynamicStagePromise.resolve()\n  }\n\n  private getStagePromise(stage: NonStaticRenderStage): Promise<void> {\n    switch (stage) {\n      case RenderStage.Runtime: {\n        return this.runtimeStagePromise.promise\n      }\n      case RenderStage.Dynamic: {\n        return this.dynamicStagePromise.promise\n      }\n      default: {\n        stage satisfies never\n        throw new InvariantError(`Invalid render stage: ${stage}`)\n      }\n    }\n  }\n\n  waitForStage(stage: NonStaticRenderStage) {\n    return this.getStagePromise(stage)\n  }\n\n  delayUntilStage<T>(\n    stage: NonStaticRenderStage,\n    displayName: string | undefined,\n    resolvedValue: T\n  ) {\n    const ioTriggerPromise = this.getStagePromise(stage)\n\n    const promise = makeDevtoolsIOPromiseFromIOTrigger(\n      ioTriggerPromise,\n      displayName,\n      resolvedValue\n    )\n\n    // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n    // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n    // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n    if (this.abortSignal) {\n      promise.catch(ignoreReject)\n    }\n    return promise\n  }\n}\n\nfunction ignoreReject() {}\n\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n// is confusing, we should clean it up.\nfunction makeDevtoolsIOPromiseFromIOTrigger<T>(\n  ioTrigger: Promise<any>,\n  displayName: string | undefined,\n  resolvedValue: T\n): Promise<T> {\n  // If we create a `new Promise` and give it a displayName\n  // (with no userspace code above us in the stack)\n  // React Devtools will use it as the IO cause when determining \"suspended by\".\n  // In particular, it should shadow any inner IO that resolved/rejected the promise\n  // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n  const promise = new Promise<T>((resolve, reject) => {\n    ioTrigger.then(resolve.bind(null, resolvedValue), reject)\n  })\n  if (displayName !== undefined) {\n    // @ts-expect-error\n    promise.displayName = displayName\n  }\n  return promise\n}\n","import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  annotateDynamicAccess,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n  type PrerenderStoreModernRuntime,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  throwForSearchParamsAccessInUseCache,\n} from './utils'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\nexport function createSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in cache contexts.'\n        )\n      case 'request':\n        return createRenderSearchParams(\n          underlyingSearchParams,\n          workStore,\n          workUnitStore\n        )\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerSearchParamsForServerPage should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderSearchParams(\n          underlyingSearchParams,\n          workUnitStore\n        )\n      case 'request':\n        return createRenderSearchParams(\n          underlyingSearchParams,\n          workStore,\n          workUnitStore\n        )\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        // We're prerendering in a mode that aborts (cacheComponents) and should stall\n        // the promise to ensure the RSC side is considered dynamic\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          '`searchParams`'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n        return Promise.resolve({})\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nfunction createStaticPrerenderSearchParams(\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n      // We are in a cacheComponents (PPR or otherwise) prerender\n      return makeHangingSearchParams(workStore, prerenderStore)\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // We are in a legacy static generation and need to interrupt the\n      // prerender when search params are accessed.\n      return makeErroringSearchParams(workStore, prerenderStore)\n    default:\n      return prerenderStore satisfies never\n  }\n}\n\nfunction createRuntimePrerenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<SearchParams> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedSearchParams(underlyingSearchParams)\n  )\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      // Semantically we only need the dev tracking when running in `next dev`\n      // but since you would never use next dev with production NODE_ENV we use this\n      // as a proxy so we can statically exclude this code from production builds.\n      return makeUntrackedSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore,\n        requestStore\n      )\n    } else {\n      return makeUntrackedSearchParams(underlyingSearchParams)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nconst CachedSearchParamsForUseCache = new WeakMap<\n  CacheLifetime,\n  Promise<SearchParams>\n>()\n\nfunction makeHangingSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (typeof prop === 'string' && prop === 'then') {\n        const expression =\n          '`await searchParams`, `searchParams.then`, or similar'\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no cacheComponents)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\n/**\n * This is a variation of `makeErroringSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */\nexport function makeErroringSearchParamsForUseCache(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve({})\n\n  const proxiedPromise = new Proxy(promise, {\n    get: function get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it. We know it\n        // isn't a dynamic access because it can only be something that was\n        // previously written to the promise and thus not an underlying\n        // searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, get)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  return promise\n}\n\nfunction makeUntrackedSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  if (requestStore.asyncApiPromises) {\n    // Do not cache the resulting promise. If we do, we'll only show the first \"awaited at\"\n    // across all segments that receive searchParams.\n    return makeUntrackedSearchParamsWithDevWarningsImpl(\n      underlyingSearchParams,\n      workStore,\n      requestStore\n    )\n  } else {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n    if (cachedSearchParams) {\n      return cachedSearchParams\n    }\n    const promise = makeUntrackedSearchParamsWithDevWarningsImpl(\n      underlyingSearchParams,\n      workStore,\n      requestStore\n    )\n    CachedSearchParams.set(requestStore, promise)\n    return promise\n  }\n}\n\nfunction makeUntrackedSearchParamsWithDevWarningsImpl(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  const promiseInitialized = { current: false }\n  const proxiedUnderlying = instrumentSearchParamsObjectWithDevWarnings(\n    underlyingSearchParams,\n    workStore,\n    promiseInitialized\n  )\n\n  let promise: Promise<SearchParams>\n  if (requestStore.asyncApiPromises) {\n    // We wrap each instance of searchParams in a `new Promise()`.\n    // This is important when all awaits are in third party which would otherwise\n    // track all the way to the internal params.\n    const sharedSearchParamsParent =\n      requestStore.asyncApiPromises.sharedSearchParamsParent\n    promise = new Promise((resolve, reject) => {\n      sharedSearchParamsParent.then(() => resolve(proxiedUnderlying), reject)\n    })\n    // @ts-expect-error\n    promise.displayName = 'searchParams'\n  } else {\n    promise = makeDevtoolsIOAwarePromise(\n      proxiedUnderlying,\n      requestStore,\n      RenderStage.Runtime\n    )\n  }\n  promise.then(\n    () => {\n      promiseInitialized.current = true\n    },\n    // If we're in staged rendering, this promise will reject if the render\n    // is aborted before it can reach the runtime stage.\n    // In that case, we have to prevent an unhandled rejection from the promise\n    // created by this `.then()` call.\n    // This does not affect the `promiseInitialized` logic above,\n    // because `proxiedUnderlying` will not be used to resolve the promise,\n    // so there's no risk of any of its properties being accessed and triggering\n    // an undesireable warning.\n    ignoreReject\n  )\n\n  return instrumentSearchParamsPromiseWithDevWarnings(\n    underlyingSearchParams,\n    promise,\n    workStore\n  )\n}\n\nfunction ignoreReject() {}\n\nfunction instrumentSearchParamsObjectWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  promiseInitialized: { current: boolean }\n) {\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  return new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized.current) {\n        if (workStore.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (workStore.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (workStore.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nfunction instrumentSearchParamsPromiseWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  promise: Promise<SearchParams>,\n  workStore: WorkStore\n) {\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  return new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && workStore.dynamicShouldError) {\n        const expression = '`searchParams.then`'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      }\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      warnForSyncAccess(workStore.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createSearchAccessError\n)\n\nfunction createSearchAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","import { createAsyncLocalStorage } from './async-local-storage'\nimport type { DynamicAccessStorage } from './dynamic-access-async-storage.external'\n\nexport const dynamicAccessAsyncStorageInstance: DynamicAccessStorage =\n  createAsyncLocalStorage()\n","import type { AsyncLocalStorage } from 'async_hooks'\n\n// Share the instance module in the next-shared layer\nimport { dynamicAccessAsyncStorageInstance } from './dynamic-access-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport interface DynamicAccessAsyncStore {\n  readonly abortController: AbortController\n}\n\nexport type DynamicAccessStorage = AsyncLocalStorage<DynamicAccessAsyncStore>\nexport { dynamicAccessAsyncStorageInstance as dynamicAccessAsyncStorage }\n","import {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { OpaqueFallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type StaticPrerenderStoreModern,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type PrerenderStoreModernRuntime,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForRoute should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForServerSegment should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore,\n            workUnitStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params\n): Promise<Params> {\n  const workStore = workAsyncStorage.getStore()\n  if (!workStore) {\n    throw new InvariantError(\n      'Missing workStore in createPrerenderParamsForClientSegment'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams) {\n          for (let key in underlyingParams) {\n            if (fallbackParams.has(key)) {\n              // This params object has one or more fallback params, so we need\n              // to consider the awaiting of this params object \"dynamic\". Since\n              // we are in cacheComponents mode we encode this as a promise that never\n              // resolves.\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                '`params`'\n              )\n            }\n          }\n        }\n        break\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderParamsForClientSegment should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'prerender-runtime':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createStaticPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<Params> {\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            // This params object has one or more fallback params, so we need\n            // to consider the awaiting of this params object \"dynamic\". Since\n            // we are in cacheComponents mode we encode this as a promise that never\n            // resolves.\n            return makeHangingParams(\n              underlyingParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-ppr': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            return makeErroringParams(\n              underlyingParams,\n              fallbackParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-legacy':\n      break\n    default:\n      prerenderStore satisfies never\n  }\n\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRuntimePrerenderParams(\n  underlyingParams: Params,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<Params> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedParams(underlyingParams)\n  )\n}\n\nfunction createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n  return makeUntrackedParams(underlyingParams)\n}\n\nfunction createRenderParamsInDev(\n  underlyingParams: Params,\n  devFallbackParams: OpaqueFallbackRouteParams | null | undefined,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<Params> {\n  let hasFallbackParams = false\n  if (devFallbackParams) {\n    for (let key in underlyingParams) {\n      if (devFallbackParams.has(key)) {\n        hasFallbackParams = true\n        break\n      }\n    }\n  }\n\n  return makeDynamicallyTrackedParamsWithDevWarnings(\n    underlyingParams,\n    hasFallbackParams,\n    workStore,\n    requestStore\n  )\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeHangingParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(\n      prerenderStore.renderSignal,\n      workStore.route,\n      '`params`'\n    ),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeErroringParams(\n  underlyingParams: Params,\n  fallbackParams: OpaqueFallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<Params> {\n  if (requestStore.asyncApiPromises && hasFallbackParams) {\n    // We wrap each instance of params in a `new Promise()`, because deduping\n    // them across requests doesn't work anyway and this let us show each\n    // await a different set of values. This is important when all awaits\n    // are in third party which would otherwise track all the way to the\n    // internal params.\n    const sharedParamsParent = requestStore.asyncApiPromises.sharedParamsParent\n    const promise: Promise<Params> = new Promise((resolve, reject) => {\n      sharedParamsParent.then(() => resolve(underlyingParams), reject)\n    })\n    // @ts-expect-error\n    promise.displayName = 'params'\n    return instrumentParamsPromiseWithDevWarnings(\n      underlyingParams,\n      promise,\n      workStore\n    )\n  }\n\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(\n        underlyingParams,\n        requestStore,\n        RenderStage.Runtime\n      )\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  const proxiedPromise = instrumentParamsPromiseWithDevWarnings(\n    underlyingParams,\n    promise,\n    workStore\n  )\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction instrumentParamsPromiseWithDevWarnings(\n  underlyingParams: Params,\n  promise: Promise<Params>,\n  workStore: WorkStore\n): Promise<Params> {\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  return new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      warnForSyncAccess(workStore.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\nimport { LayoutRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { use } from 'react'\nimport { urlSearchParamsToParsedUrlQuery } from '../route-params'\nimport { SearchParamsContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  serverProvidedParams,\n}: {\n  Component: React.ComponentType<any>\n  serverProvidedParams: null | {\n    searchParams: ParsedUrlQuery\n    params: Params\n    promises: Array<Promise<any>> | null\n  }\n}) {\n  let searchParams: ParsedUrlQuery\n  let params: Params\n  if (serverProvidedParams !== null) {\n    searchParams = serverProvidedParams.searchParams\n    params = serverProvidedParams.params\n  } else {\n    // When Cache Components is enabled, the server does not pass the params as\n    // props; they are parsed on the client and passed via context.\n    const layoutRouterContext = use(LayoutRouterContext)\n    params =\n      layoutRouterContext !== null ? layoutRouterContext.parentParams : {}\n\n    // This is an intentional behavior change: when Cache Components is enabled,\n    // client segments receive the \"canonical\" search params, not the\n    // rewritten ones. Users should either call useSearchParams directly or pass\n    // the rewritten ones in from a Server Component.\n    // TODO: Log a deprecation error when this object is accessed\n    searchParams = urlSearchParamsToParsedUrlQuery(use(SearchParamsContext)!)\n  }\n\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n","'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\nimport { LayoutRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { use } from 'react'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when cacheComponents is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  serverProvidedParams,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  serverProvidedParams: null | {\n    params: Params\n    promises: Array<Promise<any>> | null\n  }\n}) {\n  let params: Params\n  if (serverProvidedParams !== null) {\n    params = serverProvidedParams.params\n  } else {\n    // When Cache Components is enabled, the server does not pass the params\n    // as props; they are parsed on the client and passed via context.\n    const layoutRouterContext = use(LayoutRouterContext)\n    params =\n      layoutRouterContext !== null ? layoutRouterContext.parentParams : {}\n  }\n\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n","'use client'\n\n// This is a client component that only renders during SSR,\n// but will be replaced during streaming with an icon insertion script tag.\n// We don't want it to be presented anywhere so it's only visible during streaming,\n// right after the icon meta tags so that browser can pick it up as soon as it's rendered.\n// Note: we don't just emit the script here because we only need the script if it's not in the head,\n// and we need it to be hoistable alongside the other metadata but sync scripts are not hoistable.\nexport const IconMark = () => {\n  if (typeof window !== 'undefined') {\n    return null\n  }\n  return <meta name=\"«nxt-icon»\" />\n}\n"],"names":["disableSmoothScrollDuringRouteTransition","fn","options","onlyHashChange","htmlElement","document","documentElement","hasDataAttribute","dataset","scrollBehavior","process","env","NODE_ENV","getComputedStyle","warnOnce","existing","style","dontForceLayout","getClientRects","HTTPAccessFallbackBoundary","HTTPAccessFallbackErrorBoundary","React","Component","constructor","props","state","triggeredStatus","undefined","previousPathname","pathname","componentDidCatch","missingSlots","size","has","warningMessage","formattedSlots","Array","from","sort","a","b","localeCompare","map","slot","join","getDerivedStateFromError","error","isHTTPAccessFallbackError","httpStatus","getAccessFallbackHTTPStatus","getDerivedStateFromProps","render","notFound","forbidden","unauthorized","children","errorComponents","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","getAccessFallbackErrorTypeByStatus","useUntrackedPathname","useContext","MissingSlotContext","hasErrorFallback","useRouterBFCache","MAX_BF_CACHE_ENTRIES","__NEXT_CACHE_COMPONENTS","activeTree","activeStateKey","prevActiveEntry","setPrevActiveEntry","useState","initialEntry","tree","stateKey","next","newActiveEntry","n","oldEntry","clonedEntry","entry","OuterLayoutRouter","__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","ReactDOM","findDOMNode","instance","window","internal_reactDOMfindDOMNode","rectProperties","shouldSkipElement","element","includes","position","rect","getBoundingClientRect","every","item","topOfElementInViewport","viewportHeight","top","getHashFragmentDomNode","hashFragment","body","getElementById","getElementsByName","InnerScrollAndFocusHandler","componentDidMount","handlePotentialScroll","componentDidUpdate","focusAndScrollRef","apply","segmentPath","segmentPaths","length","some","scrollRefSegmentPath","segment","index","matchSegment","domNode","Element","HTMLElement","parentElement","localName","nextElementSibling","scrollIntoView","clientHeight","scrollTop","focus","ScrollAndFocusHandler","context","GlobalLayoutRouterContext","Error","InnerLayoutRouter","debugNameContext","cacheNode","maybeCacheNode","params","url","isActive","parentNavPromises","NavigationPromisesContext","use","unresolvedThenable","resolvedPrefetchRsc","prefetchRsc","rsc","useDeferredValue","resolvedRsc","isDeferredRsc","unwrappedRsc","navigationPromises","createNestedLayoutNavigationPromises","require","Provider","value","LayoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","parentParams","LoadingBoundary","loading","loadingModuleData","then","promiseForLoading","loadingRsc","loadingStyles","loadingScripts","Suspense","fallback","parallelRouterKey","errorStyles","errorScripts","templateStyles","templateScripts","template","segmentViewBoundaries","parentParallelRoutes","parallelRoutes","segmentMap","get","Map","set","parentTreeSegment","concat","activeSegment","createRouterCacheKey","bfcacheEntry","cacheKey","segmentBoundaryTriggerNode","segmentViewStateNode","SegmentBoundaryTriggerNode","SegmentViewStateNode","pagePrefix","normalizeAppPath","page","isArray","paramName","paramCacheKey","paramType","paramValue","getParamValueFromCacheKey","debugName","getBoundaryDebugNameFromSegment","childDebugNameContext","isVirtual","debugNameToDisplay","child","TemplateContext","ErrorBoundary","errorComponent","RedirectBoundary","SegmentStateProvider","Activity","mode","push","isVirtualLayout","RenderFromTemplateContext","createRenderSearchParamsFromClient","CachedSearchParams","WeakMap","makeUntrackedSearchParams","underlyingSearchParams","cachedSearchParams","promise","Promise","resolve","createRenderParamsFromClient","CachedParams","makeUntrackedParams","underlyingParams","cachedParams","clientParams","ReflectAdapter","target","prop","receiver","Reflect","bind","deleteProperty","createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","cache","logErrorOrWarn","console","warn","flushCurrentErrorIfNew","key","getMessage","logDedupedError","args","message","callStackFrames","stack","split","describeHasCheckingStringProperty","describeStringPropertyAccess","wellKnownProperties","isDefinitelyAValidIdentifier","test","JSON","stringify","stringifiedProp","Set","afterTaskAsyncStorageInstance","createAsyncLocalStorage","afterTaskAsyncStorage","isRequestAPICallableInsideAfter","throwForSearchParamsAccessInUseCache","throwWithStaticGenerationBailoutErrorWithDynamicError","route","expression","StaticGenBailoutError","workStore","constructorOpt","captureStackTrace","invalidDynamicUsageError","afterTaskStore","getStore","rootTaskSpawnPhase","RenderStage","StagedRenderingController","abortSignal","hasRuntimePrefetch","currentStage","staticInterruptReason","runtimeInterruptReason","staticStageEndTime","Infinity","runtimeStageEndTime","runtimeStageListeners","dynamicStageListeners","runtimeStagePromise","createPromiseWithResolvers","dynamicStagePromise","mayAbandon","addEventListener","reason","catch","ignoreReject","reject","once","onStage","stage","callback","InvariantError","canSyncInterrupt","boundaryStage","syncInterruptCurrentStageWithReason","abandonRenderImpl","advanceStage","getStaticInterruptReason","getRuntimeInterruptReason","getStaticStageEndTime","getRuntimeStageEndTime","abandonRender","resolveRuntimeStage","performance","now","timeOrigin","resolveDynamicStage","runtimeListeners","i","dynamicListeners","getStagePromise","waitForStage","delayUntilStage","displayName","resolvedValue","ioTriggerPromise","makeDevtoolsIOPromiseFromIOTrigger","ioTrigger","createPrerenderSearchParamsForClientPage","createSearchParamsFromClient","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","makeErroringSearchParamsForUseCache","workUnitStore","workUnitAsyncStorage","type","createStaticPrerenderSearchParams","createRenderSearchParams","throwInvariantForMissingStore","createRuntimePrerenderSearchParams","forceStatic","makeHangingPromise","renderSignal","prerenderStore","makeHangingSearchParams","makeErroringSearchParams","delayUntilRuntimeStage","requestStore","makeUntrackedSearchParamsWithDevWarnings","CachedSearchParamsForUseCache","proxiedPromise","Proxy","Object","hasOwn","annotateDynamicAccess","dynamicShouldError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","asyncApiPromises","makeUntrackedSearchParamsWithDevWarningsImpl","promiseInitialized","proxiedUnderlying","instrumentSearchParamsObjectWithDevWarnings","sharedSearchParamsParent","makeDevtoolsIOAwarePromise","Runtime","instrumentSearchParamsPromiseWithDevWarnings","ownKeys","proxiedProperties","keys","forEach","add","warnForSyncAccess","delete","createSearchAccessError","prefix","dynamicAccessAsyncStorageInstance","dynamicAccessAsyncStorage","createParamsFromClient","createPrerenderParamsForClientSegment","createServerParamsForMetadata","createServerParamsForRoute","createServerParamsForServerSegment","createStaticPrerenderParams","devFallbackParams","createRenderParamsInDev","createRenderParamsInProd","createRuntimePrerenderParams","workAsyncStorage","fallbackParams","fallbackRouteParams","makeHangingParams","makeErroringParams","hasFallbackParams","makeDynamicallyTrackedParamsWithDevWarnings","fallbackParamsProxyHandler","originalMethod","store","abortController","abort","augmentedUnderlying","defineProperty","enumerable","sharedParamsParent","instrumentParamsPromiseWithDevWarnings","createParamsAccessError","ClientPageRoot","serverProvidedParams","searchParams","layoutRouterContext","urlSearchParamsToParsedUrlQuery","SearchParamsContext","clientSearchParams","ClientSegmentRoot","slots","IconMark"],"mappings":"6IAMO,SAASA,EACdC,CAAc,CACdC,EAAmE,CAAC,CAAC,EAIrE,GAAIA,EAAQC,cAAc,CAAE,YAC1BF,IAIF,IAAMG,EAAcC,SAASC,eAAe,CAG5C,GAFgE,CAE5D,CAACC,SAFoBH,EAAYI,OAAO,CAACC,cAAc,CAEpC,YAarBR,IAKF,IAAMc,EAAWX,EAAYY,KAAK,CAACP,cAAc,CACjDL,EAAYY,KAAK,CAACP,cAAc,CAAG,OAC/B,AAACP,EAAQe,eAAe,EAAE,AAI5Bb,EAAYc,cAAc,GAE5BjB,IACAG,EAAYY,KAAK,CAACP,cAAc,CAAGM,CACrC,0EA1CgBf,2CAAAA,qCAAAA,OANS,CAAA,CAAA,IAAA,0GCwJTmB,6BAAAA,qCAAAA,2CA3IkB,CAAA,CAAA,IAAA,QACG,CAAA,CAAA,IAAA,OAM9B,CAAA,CAAA,IAAA,KACkB,CAAA,CAAA,IAAA,WACU,CAAA,CAAA,IAAA,EAsBnC,OAAMC,UAAwCC,EAAAA,OAAK,CAACC,SAAS,CAI3DC,YAAYC,CAA2C,CAAE,CACvD,KAAK,CAACA,GACN,IAAI,CAACC,KAAK,CAAG,CACXC,qBAAiBC,EACjBC,iBAAkBJ,EAAMK,QAAQ,AAClC,CACF,CAEAC,mBAA0B,CAqB1B,CAEA,OAAOe,yBAAyBC,CAAU,CAAE,CAC1C,GAAIC,CAAAA,EAAAA,EAAAA,yBAAAA,AAAyB,EAACD,GAE5B,KAFoC,CAE7B,CACLpB,gBAFiBuB,CAAAA,AAEAD,EAFAC,EAAAA,2BAAAA,AAA2B,EAACH,EAG/C,CAGF,OAAMA,CACR,CAEA,OAAOI,yBACL1B,CAA2C,CAC3CC,CAA8B,CACE,QAOhC,AAAID,EAAMK,QAAQ,GAAKJ,EAAMG,gBAAgB,EAAIH,EAAMC,eAAe,CAC7D,CAD+D,AAEpEA,qBAAiBC,EACjBC,iBAAkBJ,EAAMK,QAC1B,AADkC,EAG7B,CACLH,gBAAiBD,EAAMC,eAAe,CACtCE,iBAAkBJ,EAAMK,QAAQ,AAClC,CACF,CAEAsB,QAAS,CACP,GAAM,UAAEC,CAAQ,WAAEC,CAAS,cAAEC,CAAY,UAAEC,CAAQ,CAAE,CAAG,IAAI,CAAC/B,KAAK,CAC5D,iBAAEE,CAAe,CAAE,CAAG,IAAI,CAACD,KAAK,CAChC+B,EAAkB,CACtB,CAACC,EAAAA,qBAAqB,CAACC,SAAS,CAAC,CAAEN,EACnC,CAACK,EAAAA,qBAAqB,CAACE,SAAS,CAAC,CAAEN,EACnC,CAACI,EAAAA,qBAAqB,CAACG,YAAY,CAAC,CAAEN,CACxC,EAEA,GAAI5B,EAAiB,CACnB,IAAMmC,EACJnC,IAAoB+B,EAAAA,qBAAqB,CAACC,SAAS,EAAIN,EACnDU,EACJpC,IAAoB+B,EAAAA,qBAAqB,CAACE,SAAS,EAAIN,EACnDU,EACJrC,IAAoB+B,EAAAA,qBAAqB,CAACG,YAAY,EAAIN,SAG5D,AAAMO,GAAcC,CAAhB,CAAED,CAA6BE,EAKjC,CAAA,EAAA,EAAA,IAAA,EAAA,CAL8C,CAK9C,EALkD,MAKlD,CAAA,WACE,CAAA,EAAA,EAAA,GAAA,EAACC,OAAAA,CAAKC,KAAK,SAASC,QAAQ,YAC3BxD,GAMA8C,CAAe,CAAC9B,EAAgB,CANxBf,GAAG,AANP4C,CAMQ3C,AASnB,CAEA,OAX2B,AAWpB2C,CACT,CACF,CAEO,SAASpC,EAA2B,UACzCiC,CAAQ,MAhB0B,KAiBlCC,CAAS,WAjByB,GAkBlCC,CAAY,OAlBsB,GACxB,AAkBVC,CAlBU,AAkBF,CACwB,EAKhC,AAxBU,IAwBJ1B,EAAWuC,CAAAA,EAAAA,EAAAA,CAxBP,GAAA,EAACJ,QAAAA,MAwBMI,AAAoB,IAC/BrC,EAAesC,CAAAA,EAAAA,EAAAA,UAAAA,AAAU,EAACC,EAAAA,kBAAkB,SACtBlB,AAE5B,GAFwCC,CAEpCkB,EAFiDjB,EAIjD,GAAA,EAAA,GAAA,EAAClC,AAJ2D,EAI3DA,CACCS,CAHgB,QAGNA,EACVuB,SAAUA,EACVC,UAAWA,EACXC,aAAcA,EACdvB,aAAcA,WAEbwB,IAKA,CAAA,EAAA,EAAA,GAAA,EAAA,EAAA,QAAA,CAAA,UAAGA,GACZ,+TCpJgBiB,mBAAAA,qCAAAA,aAhCS,CAAA,CAAA,IAAA,GAgClB,SAASA,EACdG,CAA6B,CAC7BC,CAAsB,EAWtB,GAAM,CAACC,EAAiBC,EAAmB,CAAGC,CAAAA,EAAAA,EAAAA,QAAAA,AAAQ,EACpD,KAC2C,CACvCE,KAAMN,EACNO,SAAUN,EACVO,KAAM,KACR,GAKJ,GAAIN,EAAgBI,IAAI,GAAKN,EAG3B,OAAOE,EAYT,CAfyC,GAenCO,EAAqC,CACzCH,KAAMN,EACNO,SAAUN,EACVO,KAAM,IACR,EAKIE,EAAI,EACJC,EAAsCT,EACtCU,EAAkCH,EACtC,KAAoB,OAAbE,GAAqBD,EAhFyC,EAgFrCZ,CAAsB,CACpD,GAAIa,EAASJ,QAAQ,GAAKN,EAAgB,CAQxCW,EAAYJ,IAAI,CAAGG,EAASH,IAAI,CAChC,KACF,CAAO,CAELE,IACA,IAAMG,EAA4B,CAChCP,KAAMK,EAASL,IAAI,CACnBC,SAAUI,EAASJ,QAAQ,CAC3BC,KAAM,IACR,CACAI,GAAYJ,IAAI,CAAGK,EACnBD,EAAcC,CAChB,CACAF,EAAWA,EAASH,IAAI,AAC1B,CAGA,OADAL,EAAmBM,GACZA,CACT,+TCuVA,OAJA,GAIA,qCAAwBK,wDAlbjB,CAAA,CAAA,IAAA,YACc,CAAA,CAAA,IAAA,MAKd,CAAA,CAAA,IAAA,OAC4B,CAAA,CAAA,IAAA,OACL,CAAA,CAAA,IAAA,OACD,CAAA,CAAA,IAAA,OAC4B,CAAA,CAAA,IAAA,OACxB,CAAA,CAAA,IAAA,OACU,CAAA,CAAA,IAAA,OACN,CAAA,CAAA,IAAA,OACqB,CAAA,CAAA,IAAA,KACzB,CAAA,CAAA,IAAA,WAI1B,CAAA,CAAA,IAAA,OACmC,CAAA,CAAA,IAAA,OAEZ,CAAA,CAAA,IAAA,GAExBC,EACJC,EAAAA,OAAQ,CACRD,4DAA4D,CAmBxDM,EAAiB,CACrB,SACA,SACA,OACA,QACA,MACA,QACA,IACA,IACD,CAqBD,SAASS,EAAuBP,CAAoB,CAAEQ,CAAsB,EAC1E,IAAML,EAAOH,EAAQI,qBAAqB,GAC1C,OAAOD,EAAKM,GAAG,EAAI,GAAKN,EAAKM,GAAG,EAAID,CACtC,CA0BA,MAAMO,UAAmC5F,EAAAA,OAAK,CAACC,SAAS,CA4GtD4F,mBAAoB,CAClB,IAAI,CAACC,qBAAqB,EAC5B,CAEAC,oBAAqB,CAEf,IAAI,CAAC5F,KAAK,CAAC6F,iBAAiB,CAACC,KAAK,EAAE,AACtC,IAAI,CAACH,qBAAqB,EAE9B,CAEAhE,QAAS,CACP,OAAO,IAAI,CAAC3B,KAAK,CAAC+B,QAAQ,AAC5B,mBAzHF,KAAA,IAAA,GAAA,IAAA,CACE4D,qBAAAA,CAAwB,KAEtB,GAAM,mBAAEE,CAAiB,aAAEE,CAAW,CAAE,CAAG,IAAI,CAAC/F,KAAK,CAErD,GAAI6F,EAAkBC,KAAK,CAAE,CAI3B,GACED,AAA0C,MAAxBG,YAAY,CAACC,MAAM,EACrC,CAACJ,EAAkBG,YAAY,CAACE,IAAI,CAAC,AAACC,GACpCJ,EAAYhB,KAAK,CAAC,CAACqB,EAASC,IAC1BC,GAAAA,EAAAA,YAAAA,AAAY,EAACF,EAASD,CAAoB,CAACE,EAAM,IAIrD,CADA,MAIF,IAAIE,EAEiC,KAC/BlB,EAAeQ,EAAkBR,YAAY,CAanD,GAXIA,IACFkB,EA1CN,AAAIlB,AAAiB,OAAO,CA0CZD,AADM,EAxCbvG,SAASyG,IAAI,CAKpBzG,SAAS0G,cAAc,CAACF,AAoCaA,IAlCrCxG,SAAS2G,IADT,aAC0B,CAACH,EAAa,CAAC,EAAE,AAkCNA,EAK/B,AAACkB,IACHA,EApGgB,AAAtB,GAmGkB,CAnGd,IAoGYnC,GApGLE,EAAwB,KAAO,KAMnCC,GADLL,EAA6DE,WAAAA,AAAW,EA+F9C,KAAI,EAIxB,CAAEmC,CAAAA,EAlG0BlC,WAkGPmC,IA7CmE,GA6CnEA,CAAM,CAC7B,EADiC,KAMnC,KAAO,CAAED,CAAAA,aAAmBE,WAAAA,CAAU,EAAMhC,AAxFlD,SAA2BC,AAAlBD,CAAsC,EAI7C,GAAI,CAAC,SAAU,QAAQ,CAACE,QAAQ,CAACtF,iBAAiBqF,GAASE,QAAQ,EACjE,CADoE,MAC7D,EAKT,IAAMC,EAAOH,EAAQI,qBAAqB,GAC1C,OAAON,EAAeO,KAAK,CAAEC,AAAD,GAAyB,IAAfH,CAAI,CAACG,EAAK,CAClD,EA4EoEuB,IAAU,CAUtE,GAAmC,MAAM,CAArCA,EAAQK,kBAAkB,CAC5B,OAEFL,EAAUA,EAAQK,kBAAkB,AACtC,CAGAf,EAAkBC,KAAK,EAAG,EAC1BD,EAAkBR,YAAY,CAAG,KACjCQ,EAAkBG,YAAY,CAAG,EAAE,CAEnCxH,CAAAA,EAAAA,EAAAA,wCAAAA,AAAwC,EACtC,KAEE,GAAI6G,EAAc,YACdkB,EAAwBM,cAAc,GAM1C,IAAMjI,EAAcC,SAASC,eAAe,CACtCoG,EAAiBtG,EAAYkI,YAAY,EAG3C7B,EAAuBsB,EAAwBrB,KAQnDtG,EAAYmI,SAAS,CAR+C,AAQ5C,EAGpB,AAAC9B,EAAuBsB,EAAwBrB,IAEhDqB,EAAwBM,WAFyC,GAE3B,GAE5C,EACA,CAEEpH,iBAAiB,EACjBd,eAAgBkH,EAAkBlH,cAAc,AAClD,GAIFkH,EAAkBlH,cAAc,EAAG,EAGnC4H,EAAQS,KAAK,EACf,CACF,EAgBF,CAEA,SAASC,EAAsB,aAC7BlB,CAAW,UACXhE,CAAQ,CAIT,EACC,IAAMmF,EAAUrE,GAAAA,EAAAA,UAAAA,AAAU,EAACsE,EAAAA,yBAAyB,EACpD,GAAI,CAACD,EACH,MAAM,CADM,MACN,cAAuD,CAAvD,AAAIE,MAAM,8CAAV,oBAAA,OAAA,kBAAA,gBAAA,EAAsD,GAG9D,MACE,CADF,AACE,EAAA,EAAA,GAAA,EAAC3B,EAAAA,AADH,CAEIM,YAAaA,EACbF,kBAAmBqB,EAAQrB,iBAAiB,UAE3C9D,GAGP,CAKA,SAASsF,EAAkB,MACzB5D,CAAI,aACJsC,CAAW,kBACXuB,CAAgB,CAChBC,UAAWC,CAAc,QACzBC,CAAM,KACNC,CAAG,UACHC,CAAQ,CAST,EACC,IAuCIS,EAvCElB,EAAUrE,CAAAA,EAAAA,EAAAA,UAAAA,AAAU,EAACsE,EAAAA,yBAAyB,EAGpD,GAF0BtE,CAAAA,EAAAA,EAAAA,UAAAA,AAAU,EAACgF,EAAAA,yBAAyB,EAE1D,CAACX,EACH,MAAM,CADM,MACN,cAAuD,CAAvD,AAAIE,MAAM,8CAAV,oBAAA,OAAA,mBAAA,gBAAA,CAAsD,GAG9D,IAAMG,EACe,OAAnBC,EACIA,EASCM,CAAAA,EAAAA,EAAAA,GAAAA,AAAG,EAACC,EAAAA,GAPL,AACA,EADE,aAOqB,EASvBC,EACsB,OAA1BT,EAAUU,WAAW,CAAYV,EAAUU,WAAW,CAAGV,EAAUW,GAAG,CAKlEA,EAAWC,CAAAA,EAAAA,EAAAA,EArB0D,cAqB1DA,AAAgB,EAACZ,EAAUW,GAAG,CAAEF,GAOjD,GAAIK,CAAAA,EAAAA,EAAAA,aAAAA,AAAa,EAACH,GAAM,CACtB,IAAMI,EAAeR,CAAAA,EAAAA,EAAAA,GAAAA,AAAG,EAACI,EACJ,MAAM,EAAvBI,GAKFR,CAAAA,EAAAA,EAAAA,GAAAA,AAAG,EAACC,EAAAA,kBAAkB,EAExBK,EAAcE,CAChB,MAEMJ,AAAQ,CAFP,KAEa,IAChBJ,CAAAA,EAAAA,EAAAA,GAAG,AAAHA,EAAIC,EAAAA,kBAAkB,EAExBK,EAAcF,EAiBhB,IAAInG,EAAWqG,EA6Bf,MAjBE,CAAA,AAiBKrG,EAjBL,EAAA,GAAA,EAAC6G,EAAAA,UAD2E,SACxD,CAACF,QAAQ,CAAA,CAC3BC,MAAO,CACLE,WAAYpF,EACZqF,gBAAiBvB,EACjBwB,kBAAmBhD,EACnBiD,aAAcvB,EACdH,iBAAkBA,EAGlBI,IAAKA,EACLC,SAAUA,CACZ,WAEC5F,GAKP,CAMA,SAASkH,EAAgB,MACvBxG,CAAI,SACJyG,CAAO,UACPnH,CAAQ,CAKT,EASC,IAAIoH,EAYJ,GALEA,CAKEA,CAViB,UAAnB,OAAOD,GACK,OAAZA,GACA,AAAiC,YACjC,OADQA,EAAgBE,IAAI,CAGRtB,CAAAA,EAAAA,EAAAA,GAAAA,AAAG,EAACuB,AADEH,GAGNA,EAGC,CACrB,IAAMI,EAAaH,CAAiB,CAAC,EAAE,CACjCI,EAAgBJ,CAAiB,CAAC,EAAE,CACpCK,EAAiBL,CAAiB,CAAC,EAAE,CAC3C,MACE,CADF,AACE,EAAA,EAAA,GAAA,EAACM,EAAAA,AADH,QACW,CAAA,CACPhH,KAAMA,EACNiH,SACE,CADFA,AACE,EAAA,EAAA,IAAA,EAAA,CADFA,CACE,QAAA,CAAA,WACGH,EACAC,EACAF,cAIJvH,GAGP,CAEA,MAAO,CAAP,AAAO,EAAA,EAAA,GAAA,EAAA,EAAP,AAAO,QAAA,CAAA,UAAGA,GACZ,CAMe,SAASkC,EAAkB,CACxC0F,mBAAiB,OACjBrI,CAAK,aACLsI,CAAW,cACXC,CAAY,gBACZC,CAAc,iBACdC,CAAe,UACfC,CAAQ,UACRpI,CAAQ,WACRC,CAAS,CACTC,cAAY,uBACZmI,CAAqB,CAatB,EACC,IAAM/C,EAAUrE,CAAAA,EAAAA,EAAAA,UAAAA,AAAU,EAAC+F,EAAAA,mBAAmB,EAC9C,GAAI,CAAC1B,EACH,MAAM,CADM,MACN,cAA2D,CAA3D,AAAIE,MAAM,kDAAV,oBAAA,OAAA,kBAAA,eAAA,EAA0D,GAGlE,GAAM,YACJyB,CAAU,iBACVC,CAAe,mBACfC,CAAiB,cACjBC,CAAY,KACZtB,CAAG,UACHC,CAAQ,kBACRL,CAAgB,CACjB,CAAGJ,EAIEgD,EAAuBpB,EAAgBqB,cAAc,CACvDC,EAAaF,EAAqBG,GAAG,CAACV,GAGrCS,IACHA,EAAa,IAAIE,EADF,EAEfJ,EAAqBK,GAAG,CAACZ,EAAmBS,IAE9C,IAAMI,EAAoB3B,CAAU,CAAC,EAAE,CACjC9C,EACkB,OAElB,AACA,AAHJgD,EAII,CAACY,EAAkB,CACnBZ,EAAkB0B,MAAM,CAAC,CAACD,EAAmBb,EAAkB,EAY/DxG,EAAa0F,CAAU,CAAC,EAAE,CAACc,EAAkB,MAdR,AAexBxJ,IAAfgD,GAKF2E,GAAAA,CAL4B,CAK5BA,GAAAA,AAAG,EAACC,EAAAA,cArBsE,IAqBpD,EAGxB,IAAM2C,EAAgBvH,CAAU,CAAC,EAAE,CAC7BC,EAAiBuH,CAAAA,EAAAA,EAAAA,oBAAAA,AAAoB,EAACD,GAAe,GAQvDE,EAA0C5H,CAAAA,AARmB,EAQnBA,EAAAA,eARsC,CAQtCA,AAAgB,EAC5DG,EACAC,GAEErB,EAAmC,EAAE,CACzC,EAAG,CACD,IAAM0B,EAAOmH,EAAanH,IAAI,CACxBC,EAAWkH,EAAalH,QAAQ,CAChC0C,EAAU3C,CAAI,CAAC,EAAE,CACjBoH,EAAWF,CAAAA,EAAAA,EAAAA,oBAAAA,AAAoB,EAACvE,GAGhCmB,EAAY6C,EAAWC,GAAG,CAACQ,IAAa,KA+B1CpD,EAASuB,EACb,GAAIpI,MAAMyK,OAAO,CAACjF,GAAU,CAI1B,IAAMkF,EAAYlF,CAAO,CAAC,EAAE,CACtBmF,EAAgBnF,CAAO,CAAC,EAAE,CAC1BoF,EAAYpF,CAAO,CAAC,EAAE,CACtBqF,EAAaC,CAAAA,EAAAA,EAAAA,yBAAAA,AAAyB,EAACH,EAAeC,EACzC,MAAM,EAArBC,IACFhE,EAAS,CACP,GAAGuB,CAAY,CACf,CAACsC,EAAU,CAAEG,EACf,CAEJ,CAEA,IAAME,EAAYC,AAsGtB,SAASA,AAAgCxF,CAAgB,EACvD,GAAIA,AAAY,KAAK,GAEnB,MAAO,IAET,GAAuB,UAAnB,AAA6B,OAAtBA,EACT,GAeAA,AAAY,CAfRqG,UAAgBrG,EAClB,OAAOjG,CADqB,IAG5B,OAAOiG,EAAU,IAIrB,OADsBA,AACfmF,CADsB,CAAC,EAAE,CACT,GACzB,EApHsDnF,GAI5CyF,EAAwBF,GAAarE,EAWrCyE,EAAqBD,KADK3L,IAAdwL,OACqBxL,EAAYmH,EAU7C6B,EAAoBL,EAAgBI,OAAO,CAC7C8C,EACF,GAAA,EAAA,CADEA,GACF,EAACC,EAAAA,IADCD,WACc,CAACtD,QAAQ,CAAA,CAEvBC,MACE,CADFA,AACE,EAAA,EAAA,IAAA,EAAC1B,CADH0B,CACG1B,CAAsBlB,YAAaA,YAClC,CAAA,EAAA,EAAA,GAAA,EAACmG,EAAAA,aAAa,CAAA,CACZC,eAAgB7K,EAChBsI,YAAaA,EACbC,aAAcA,WAEd,CAAA,EAAA,EAAA,GAAA,EAACZ,EAAD,AAACA,CACCxG,KAAMsJ,EACN7C,QAASC,WAET,CAAA,EAAA,EAAA,GAAA,EAACxJ,EAAD,AAACA,0BAA0B,CAAA,CACzBiC,SAAUA,EACVC,UAAWA,EACXC,aAAcA,WAEd,CAAA,EAAA,EAAA,IAAA,EAACsK,CAAD,CAACA,gBAAgB,CAAA,WACf,GAAA,EAAA,GAAA,EAAC/E,EAAAA,CACCK,IAAKA,EACLjE,KAAMA,EACNgE,OAAQA,EACRF,UAAWA,EACXxB,YAAaA,EACbuB,iBAAkBuE,EAClBlE,SAAUA,GAAYjE,IAAaN,IAxFH,cACN,kBAkGvC0G,EACAC,EACAC,IAtCItG,GAkET3B,EAASyK,IAAI,CAACR,GAEdpB,EAAeA,EAAajH,IAAI,AAClC,OAA0B,OAAjBiH,EAAsB,AAE/B,OAAO7I,CACT,+TCxrBA,UAAA,qCAAwB2K,2CAHoB,CAAA,CAAA,IAAA,QACZ,CAAA,CAAA,IAAA,GAEjB,SAASA,IACtB,IAAM3K,EAAWc,CAAAA,EAAAA,EAAAA,UAAAA,AAAU,EAACoJ,EAAAA,eAAe,EAC3C,MAAO,CAAP,AAAO,EAAA,EAAA,GAAA,EAAA,EAAP,AAAO,QAAA,CAAA,UAAGlK,GACZ,+TCWgB4K,qCAAAA,qCAAAA,KAhBhB,IAAMC,EAAqB,IAAIC,QAgBxB,SAASF,EACdI,CAAoC,EAZpC,IAAMC,EAAqBJ,EAAmBvC,GAAG,CAAC0C,GAClD,GAAIC,EACF,OAAOA,EAGT,IAAMC,EAAUC,GAJQ,KAIAC,OAAO,CAACJ,GAGhC,OAFAH,EAAmBrC,GAAG,CAQWwC,AARVA,EAAwBE,GAExCA,CAOT,+TCvBaN,qCAAAA,qCAAAA,KAAN,IAAMA,EAMLlE,EAFAkE,CAAAA,CAAAA,IAEQ,GACRA,EAHAA,cAAkC,kBAGA,4BAJlClE,QAAQ,2RCcA2E,+BAAAA,qCAAAA,KAdhB,IAAMC,EAAe,IAAIR,QAclB,SAASO,EACdK,CAAoB,EAZpB,IAAMD,EAAeH,EAAahD,GAAG,CAACkD,GACtC,GAAIC,EACF,OAAOA,EAGT,GAJkB,CAIZP,EAAUC,QAAQC,OAAO,CAACI,AASLE,GAN3B,OAFAJ,EAAa9C,GAAG,CAACgD,EAAkBN,GAE5BA,CAOT,+TCrBaG,+BAAAA,qCAAAA,KAAN,IAAMA,EAKL3E,EAAQ,CAAA,CAAA,EAFP2E,EAEO,GACRA,GAH6B,yBAGD,4BAJ7B3E,QAAQ,2RCFFiF,iBAAAA,qCAAAA,IAAN,OAAMA,EACX,OAAOrD,IACLsD,CAAS,CACTC,CAAqB,CACrBC,CAAiB,CACZ,CACL,IAAMlF,EAAQmF,QAAQzD,GAAG,CAACsD,EAAQC,EAAMC,SACxC,AAAqB,YAAjB,AAA6B,OAAtBlF,EACFA,EAAMoF,IAAI,CAACJ,GAGbhF,CACT,CAEA,OAAO4B,IACLoD,CAAS,CACTC,CAAqB,CACrBjF,CAAU,CACVkF,CAAa,CACJ,CACT,OAAOC,QAAQvD,GAAG,CAACoD,EAAQC,EAAMjF,EAAOkF,EAC1C,CAEA,OAAOpN,IAAsBkN,CAAS,CAAEC,CAAqB,CAAW,CACtE,OAAOE,QAAQrN,GAAG,CAACkN,EAAQC,EAC7B,CAEA,OAAOI,eACLL,CAAS,CACTC,CAAqB,CACZ,CACT,OAAOE,QAAQE,cAAc,CAACL,EAAQC,EACxC,CACF,yGCQgBK,8CAAAA,qCAAAA,ydAzCO,CAAA,CAAA,IAAA,mIAEvB,IAAMC,EAAsC,CAAEC,QAAS,IAAK,EAGtDC,EACmB,YAAvB,OAAOvO,EAAMuO,KAAK,CACdvO,EAAMuO,KAAK,CACX,AAAC3P,GAA+BA,EAKhC4P,EAEFC,QAAQC,IAAI,CA0BT,SAASN,EACdS,CAAoC,EAEpC,OAAO,SAAyB,AAAhBC,GAAmBC,CAAU,EAkBzCP,EAjBcK,EA/BhBJ,GA+B8BM,GAmBhC,CACF,CAnDYtN,AAKmB8M,EAE7B,AAACK,CAyCkBI,EAhDJ,CAQb,GAAI,CACFR,EAAeH,EAASC,OAAO,CACjC,QAAU,CACRD,EAASC,OAAO,CAAG,IACrB,CACF,6BAP0E,4DCN5Dc,iCAAiC,CAAA,kBAAjCA,GAPAC,4BAA4B,CAAA,kBAA5BA,GAeHC,mBAAmB,CAAA,kBAAnBA,uEAjBb,IAAMC,EAA+B,6BAE9B,SAASF,EAA6BvB,CAAc,CAAEC,CAAY,SACvE,AAAIwB,EAA6BC,IAAI,CAACzB,GAC7B,CAAC,EAAE,CADiC,CAC/BD,EAAO,CAAC,EAAEC,EAAK,EAAE,CAAC,CAEzB,CAAC,EAAE,EAAED,EAAO,CAAC,EAAE2B,KAAKC,SAAS,CAAC3B,GAAM,GAAG,CAAC,AACjD,CAEO,SAASqB,EACdtB,CAAc,CACdC,CAAY,EAEZ,IAAM4B,EAAkBF,KAAKC,SAAS,CAAC3B,GACvC,MAAO,CAAC,cAAc,EAAED,EAAO,EAAE,EAAE6B,EAAgB,OAAO,EAAEA,EAAgB,IAAI,EAAE7B,EAAO,cAAc,CAAC,AAC1G,CAEO,IAAMwB,EAAsB,IAAIM,IAAI,CACzC,iBACA,gBACA,uBACA,WACA,UACA,iBAGA,OACA,QACA,UAGA,SAKA,cACA,aAGA,SACA,WACA,aACD,yGC7CYC,gCAAAA,qCAAAA,KAAN,IAAMA,EACXC,CAAAA,EAAAA,EAHsC,CAAA,CAAA,IAAA,GAGtCA,uBAAAA,AAAuB,2GCahBC,wBAAAA,qCAAAA,EAAAA,6BAAqB,YAdyC,CAAA,CAAA,IAAA,yFCwBvDC,+BAA+B,CAAA,kBAA/BA,GAdAC,oCAAoC,CAAA,kBAApCA,GATAC,qDAAqD,CAAA,kBAArDA,+EAJsB,CAAA,CAAA,IAAA,OACA,CAAA,CAAA,IAAA,GAG/B,SAASA,EACdC,CAAa,CACbC,CAAkB,EAElB,MAAM,OAAA,cAEL,CAFK,IAAIC,EAAAA,qBAAqB,CAC7B,CAAC,MAAM,EAAEF,EAAM,4EAA4E,EAAEC,EAAW,0HAA0H,CAAC,EAD/N,oBAAA,OAAA,kBAAA,iBAAA,CAEN,EACF,CAEO,SAASH,EACdK,CAAoB,CACpBC,CAAwB,EAExB,IAAM9O,EAAQ,OAAA,cAEb,CAFa,AAAI8F,MAChB,CAAC,MAAM,EAAE+I,EAAUH,KAAK,CAAC,2XAA2X,CAAC,EADzY,oBAAA,OAAA,mBAAA,gBAAA,CAEd,EAKA,OAHA5I,MAAMiJ,iBAAiB,CAAC/O,EAAO8O,GAC/BD,EAAUG,wBAAwB,GAAKhP,EAEjCA,CACR,CAEO,SAASuO,IACd,IAAMU,EAAiBX,EAAAA,qBAAqB,CAACY,QAAQ,GACrD,MAAOD,CAAAA,QAAAA,KAAAA,EAAAA,EAAgBE,kBAAAA,AAAkB,IAAK,QAChD,0FC3BYC,WAAW,CAAA,kBAAXA,GAUCC,yBAAyB,CAAA,kBAAzBA,+EAbkB,CAAA,CAAA,IAAA,OACY,CAAA,CAAA,IAAA,GAEpC,IAAKD,IAAAA,UAAAA,CAAAA,UAAAA,GAAAA,yGAAAA,EAUL,OAAMC,EAgBX5Q,YACU6Q,EAAkC,IAAI,CACtCC,CAA2B,CACnC,MAFQD,WAAAA,CAAAA,OACAC,kBAAAA,CAAAA,OAjBVC,YAAAA,CAAAA,OAEAC,qBAAAA,CAAsC,UACtCC,sBAAAA,CAAuC,UACvCC,kBAAAA,CAA6BC,SAC7BC,mBAAAA,CAA8BD,SAEtBE,qBAAAA,CAA2C,EAAE,MAC7CC,qBAAAA,CAA2C,EAAE,MAE7CC,mBAAAA,CAAsBC,CAAAA,EAAAA,EAAAA,0BAAAA,AAA0B,SAChDC,mBAAAA,CAAsBD,CAAAA,EAAAA,EAAAA,0BAAAA,AAA0B,SAEhDE,UAAAA,EAAsB,EAMxBb,IACFA,EAAYc,OADG,SACa,CAC1B,QACA,KACE,GAAM,QAAEC,CAAM,CAAE,CAAGf,EACf,IAAI,CAACE,YAAY,CAAA,GAAwB,CAC3C,IAAI,CAACQ,mBAAmB,CAACrE,OAAO,CAAC2E,KAAK,CAACC,GACvC,IAAI,CAACP,MADgD,aAC7B,CAACQ,MAAM,CAACH,KAGhC,GAJkF,CAI9E,CAACb,YAAY,CAAA,GACA,GACjB,CADA,IAAI,CAACA,YAAY,IAEjB,IAAI,CAACU,mBAAmB,CAACvE,OAAO,CAAC2E,KAAK,CAACC,GACvC,IAAI,CAACL,MADgD,aAC7B,CAACM,MAAM,CAACH,GAEpC,EACA,CAAEI,EAJoF,IAI9E,CAAK,GAGf,IAAI,CAACN,UAAU,EAAG,EAEtB,CAEAO,QAAQC,CAA2B,CAAEC,CAAoB,CAAE,CACzD,GAAI,IAAI,CAACpB,YAAY,EAAImB,EACvBC,KAD8B,IAEzB,GAAID,GAA+B,CAA/BA,EACT,IAAI,CAACb,qBAAqB,CAAC5E,IAAI,CAAC0F,QAC3B,GAAID,GAA+B,CAA/BA,EACT,IAAI,CAACZ,qBAAqB,CAAC7E,IAAI,CAAC0F,QAGhC,MAAM,OAAA,cAAoD,CAApD,IAAIC,EAAAA,cAAc,CAAC,CAAC,sBAAsB,EAAEF,EAAAA,CAAO,EAAnD,oBAAA,OAAA,mBAAA,gBAAA,CAAmD,EAE7D,CAEAG,kBAAmB,CAEjB,GAAI,AAAiB,GAAyB,KAAtC,CAACtB,YAAY,CACnB,OAAO,EAGT,IAAMuB,EAAgB,IAAI,CAACxB,kBAAkB,CAAA,EAAA,EAG7C,OAAO,IAAI,CAACC,YAAY,CAAGuB,CAC7B,CAEAC,oCAAoCX,CAAa,CAAE,CACjD,GAAqB,GAAyB,CAA1C,IAAI,CAACb,YAAY,EAOrB,GAAI,IAAI,CAACW,UAAU,CACjB,CADmB,MACZ,IAAI,CAACc,iBAAiB,GAK/B,OAAQ,IAAI,CAACzB,YAAY,EACvB,KAAA,EACE,IAAI,CAACC,qBAAqB,CAAGY,EAC7B,IAAI,CAACa,YAAY,CAAA,GACjB,MAEF,MAAA,EAOM,IAAI,CAAC3B,kBAAkB,EAAE,CAC3B,IAAI,CAACG,sBAAsB,CAAGW,EAC9B,IAAI,CAACa,YAAY,CAAA,IAEnB,MAKJ,EACF,CAEAC,0BAA2B,CACzB,OAAO,IAAI,CAAC1B,qBAAqB,AACnC,CAEA2B,2BAA4B,CAC1B,OAAO,IAAI,CAAC1B,sBAAsB,AACpC,CAEA2B,uBAAwB,CACtB,OAAO,IAAI,CAAC1B,kBAAkB,AAChC,CAEA2B,wBAAyB,CACvB,OAAO,IAAI,CAACzB,mBAAmB,AACjC,CAEA0B,eAAgB,CACd,GAAI,CAAC,IAAI,CAACpB,UAAU,CAClB,CADoB,KACd,OAAA,cAEL,CAFK,IAAIU,EAAAA,cAAc,CACtB,0EADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,GAGF,IAAI,CAACI,iBAAiB,EACxB,CAEQA,mBAAoB,CAU1B,GAAM,cAAEzB,CAAY,CAAE,CAAG,IAAI,CAC7B,OAAQA,GACN,KAAA,EACE,IAAI,CAACA,YAAY,CAAA,EACjB,IAAI,CAACgC,mBAAmB,GACxB,MAEF,MAAA,EACE,IAAI,CAAChC,YAAY,CAAA,EACjB,MASJ,CACF,CAEA0B,aACEP,CAAqE,CACrE,CAGA,GAAIA,GAAS,IAAI,CAACnB,YAAY,CAC5B,CAD8B,MAIhC,IAAIA,EAAe,IAAI,CAACA,YAAY,CAOpC,GANA,IAAI,CAACA,YAAY,CAAGmB,EAEhBnB,EAAAA,GAAsCmB,GAAAA,GAA8B,CACtE,IAAI,CAAChB,kBAAkB,CAAG8B,YAAYC,GAAG,GAAKD,YAAYE,UAAU,CACpE,IAAI,CAACH,mBAAmB,IAEtBhC,EAAAA,GAAsCmB,GAAAA,EAA8B,CACtE,IAAI,CAACd,mBAAmB,CAAG4B,YAAYC,GAAG,GAAKD,YAAYE,UAAU,CACrE,IAAI,CAACC,mBAAmB,GACxB,MACF,CACF,CAGQJ,qBAAsB,CAC5B,IAAMK,EAAmB,IAAI,CAAC/B,qBAAqB,CACnD,IAAK,IAAIgC,EAAI,EAAGA,EAAID,EAAiBlN,MAAM,CAAEmN,IAAK,AAChDD,CAAgB,CAACC,EAAE,GAErBD,EAAiBlN,MAAM,CAAG,EAC1B,IAAI,CAACqL,mBAAmB,CAACnE,OAAO,EAClC,CAGQ+F,qBAAsB,CAC5B,IAAMG,EAAmB,IAAI,CAAChC,qBAAqB,CACnD,IAAK,IAAI+B,EAAI,EAAGA,EAAIC,EAAiBpN,MAAM,CAAEmN,IAAK,AAChDC,CAAgB,CAACD,EAAE,GAErBC,EAAiBpN,MAAM,CAAG,EAC1B,IAAI,CAACuL,mBAAmB,CAACrE,OAAO,EAClC,CAEQmG,gBAAgBrB,CAA2B,CAAiB,CAClE,OAAQA,GACN,KAAA,EACE,OAAO,IAAI,CAACX,mBAAmB,CAACrE,OAAO,AAEzC,MAAA,EACE,OAAO,IAAI,CAACuE,mBAAmB,CAACvE,OAAO,AAEzC,SAEE,MAAM,OAAA,cAAoD,CAApD,IAAIkF,EAAAA,cAAc,CAAC,CAAC,sBAAsB,EAAEF,EAAAA,CAAO,EAAnD,oBAAA,OAAA,mBAAA,gBAAA,CAAmD,EAE7D,CACF,CAEAsB,aAAatB,CAA2B,CAAE,CACxC,OAAO,IAAI,CAACqB,eAAe,CAACrB,EAC9B,CAEAuB,gBACEvB,CAA2B,CAC3BwB,CAA+B,CAC/BC,CAAgB,CAChB,KAyBFG,SAAuB,GAtBf5G,KAFmB,IAAI,CAEb2G,AAFcN,eAAe,CAACrB,GAyBhDwB,EArBIA,EAsBJC,EArBIA,EA4BEzG,EAAU,CARe,GAQXC,EA9BhByG,CAuBY,KAOe,CAACxG,EAAS2E,KACvC+B,EAAUzK,IAAI,CAAC+D,EAAQY,IAAI,CAAC,KAAM2F,GAAgB5B,EACpD,GACoB3R,SAAhBsT,EAA2B,EAE7BxG,EAAQwG,WAAW,CAAGA,CAAAA,EAEjBxG,GA1BL,OAHI,IAAI,CAAC2D,WAAW,EAClB3D,AADoB,EACZ2E,KAAK,CAACC,GAET5E,CACT,CACF,CAEA,SAAS4E,IAAgB,wFCrJTiC,wCAAwC,CAAA,kBAAxCA,GA3EAC,4BAA4B,CAAA,kBAA5BA,GAoCHC,mCAAmC,CAAA,kBAAnCA,GAGGC,qCAAqC,CAAA,kBAArCA,GAgQAC,mCAAmC,CAAA,kBAAnCA,+EA5Ue,CAAA,CAAA,IAAA,OAMxB,CAAA,CAAA,IAAA,OAWA,CAAA,CAAA,IAAA,OACwB,CAAA,CAAA,IAAA,OAIxB,CAAA,CAAA,IAAA,OACqD,CAAA,CAAA,IAAA,OAKrD,CAAA,CAAA,IAAA,OAIA,CAAA,CAAA,IAAA,GAKA,SAASH,EACdhH,CAAoC,CACpCoD,CAAoB,EAEpB,IAAMgE,EAAgBC,EAAAA,oBAAoB,CAAC5D,QAAQ,GACnD,GAAI2D,EACF,OAAQA,EAAcE,IAAI,AADT,EAEf,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,OAAOC,EAAkCnE,EAAWgE,EACtD,KAAK,oBACH,MAAM,OAAA,cAEL,CAFK,IAAIhC,EAAAA,cAAc,CACtB,6EADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIA,EAAAA,cAAc,CACtB,wEADI,oBAAA,OAAA,mBAAA,eAAA,EAEN,EACF,KAAK,UACH,OAAOoC,EACLxH,EACAoD,EACAgE,EAIN,CAEFK,CAAAA,EAAAA,EAAAA,6BAAAA,AAA6B,GAC/B,GArC4B,CAAA,CAAA,IAAA,GAwCrB,IAAMR,EACXC,EAEK,SAASA,EACdlH,CAAoC,CACpCoD,CAAoB,EAEpB,IAAMgE,EAAgBC,EAAAA,oBAAoB,CAAC5D,QAAQ,GACnD,GAAI2D,EACF,OAAQA,EAAcE,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,OAAOC,EAAkCnE,EAAWgE,EACtD,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIhC,EAAAA,cAAc,CACtB,iFADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,wBAsFTpF,IArFM,OAAO0H,EACL1H,EAqFRoH,EApFQA,EAsFDa,GAH6B,AAG7BA,EAAAA,IAFmC,kBAEnCA,AAAsB,EAC3Bb,EACArH,EAA0BC,GAtFxB,KAAK,UACH,OAAOwH,EACLxH,EACAoD,EACAgE,EAIN,CAEFK,CAAAA,EAAAA,EAAAA,6BAAAA,AAA6B,GAC/B,CAEO,SAASV,EACd3D,CAAoB,EAEpB,GAAIA,EAAUuE,WAAW,CAGvB,CAHyB,MAGlBxH,QAAQC,OAAO,CAAC,CAAC,GAG1B,IAAMgH,EAAgBC,EAAAA,oBAAoB,CAAC5D,QAAQ,GACnD,GAAI2D,EACF,OAAQA,EAAcE,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBAGH,MAAOM,CAAAA,EAAAA,EAAAA,kBAAAA,AAAkB,EACvBR,EAAcS,YAAY,CAC1BzE,EAAUH,KAAK,CACf,iBAEJ,KAAK,oBACH,MAAM,OAAA,cAEL,CAFK,IAAImC,EAAAA,cAAc,CACtB,yFADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIA,EAAAA,cAAc,CACtB,oFADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,gBACL,IAAK,mBACL,IAAK,UACH,OAAOjF,QAAQC,OAAO,CAAC,CAAC,EAG5B,CAEFqH,CAAAA,EAAAA,EAAAA,6BAAAA,AAA6B,GAC/B,CAEA,SAASF,EACPnE,CAAoB,CACpB0E,CAAoC,EAEpC,GAAI1E,EAAUuE,WAAW,CAGvB,CAHyB,MAGlBxH,QAAQC,OAAO,CAAC,CAAC,GAG1B,OAAQ0H,EAAeR,IAAI,EACzB,IAAK,YACL,IAAK,uBAyDPlE,EAvDmCA,EAwDnC0E,EAxD8CA,EA0D9C,CAHoB,GAGd7H,EAAqBJ,EAAmBvC,EAFV,CAEa,CAACwK,GAClD,GAAI7H,EACF,OAAOA,EAGT,IAAMC,EAAU0H,GAAAA,AAJQ,EAIRA,kBAAAA,AAAkB,EAChCE,EAAeD,YAAY,CAC3BzE,EAAUH,KAAK,CACf,kBAGIoF,EAAiB,IAAIC,MAAMpI,EAAS,CACxC5C,IAAIsD,CAAM,CAAEC,CAAI,CAAEC,CAAQ,EACxB,GAAIyH,OAAOC,MAAM,CAACtI,EAASW,GAIzB,IAJgC,GAIzBF,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,GAG1C,OAAQD,GACN,IAAK,OAIH,MADA4H,CAAAA,EAAAA,EAAAA,qBAAAA,AAAqB,EAACvF,AADpB,wDACgC4E,GAC3BnH,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,EAE1C,KAAK,SAIH,MADA2H,GAAAA,EAAAA,qBAAAA,AAAqB,EADnB,AACoBvF,yDAAY4E,GAC3BnH,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,EAG1C,SACE,OAAOH,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,EAE5C,CACF,CACF,GAGA,OADAjB,EAAmBrC,GAAG,CAACsK,EAAgBO,GAChCA,CAnGL,KAAK,gBACL,IAAK,uBAsGPjF,EAnGoCA,EAoGpC0E,EApG+CA,EAsG/C,CAHoB,GAGd7H,EAAqBJ,EAAmBvC,EAFU,CAEP,CAAC8F,GAClD,GAAInD,EACF,OAAOA,EAOT,IAAMC,EAAUC,GARQ,KAQAC,OAAO,CAJA,AAICJ,CAJA,GAM1BqI,EAAiB,IAAIC,MAAMpI,EAAS,CACxC5C,IAAIsD,CAAM,CAAEC,CAAI,CAAEC,CAAQ,EACxB,GAAIyH,OAAOC,MAAM,CAACtI,EAASW,GAIzB,IAJgC,GAIzBF,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,GAG1C,GAAoB,UAAhB,OAAOD,GAA8B,SAATA,EAAiB,CAC/C,IAAMqC,EACJ,wDACEE,EAAUsF,kBAAkB,CAC9B1F,CADgC,AAChCA,EAAAA,EAAAA,qDAAAA,AAAqD,EACnDI,EAAUH,KAAK,CACfC,GAE+B,iBAAiB,CAAzC4E,EAAeR,IAAI,CAE5BqB,CAAAA,EAAAA,EAAAA,oBAAAA,AAAoB,EAClBvF,EAAUH,KAAK,CACfC,EACA4E,EAAec,eAAe,EAIhCC,CAAAA,EAAAA,EAAAA,gCAAAA,AAAgC,EAC9B3F,EACAE,EACA0E,EAGN,CACA,OAAOnH,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,EAC1C,CACF,GAGA,OADAjB,EAAmBrC,GAAG,CAAC4F,EAAWiF,GAC3BA,CAtJL,SACE,OAAOP,CACX,CACF,CAYA,SAASN,EACPxH,CAAoC,CACpCoD,CAAoB,CACpB8E,CAA0B,SAEtB9E,AAAJ,EAAcuE,WAAW,CAGhBxH,CAHkB,OAGVC,OAAO,CAAC,CAAC,GAYfL,EAA0BC,EAGvC,CAGA,IAAMH,EAAqB,IAAIC,QAEzBsI,EAAgC,IAAItI,QAmHnC,SAASqH,EACd/D,CAAoB,EAEpB,IAAMnD,EAAqBmI,EAA8B9K,GAAG,CAAC8F,GAC7D,GAAInD,EACF,OAAOA,EAGT,IAAMC,EAAUC,GAJQ,KAIAC,OAAO,CAAC,CAAC,GAE3BiI,EAAiB,IAAIC,MAAMpI,EAAS,CACxC5C,IAAK,SAASA,EAAIsD,CAAM,CAAEC,CAAI,CAAEC,CAAQ,SAClCyH,OAAOC,MAAM,CAACtI,EAASW,IAST,GATgB,OAShC,EACCA,KADMA,GACG,SAATA,CAAmB,EAACuB,EAAAA,mBAAmB,CAAC1O,GAAG,CAACmN,IAE7CkC,CAFiD,EAEjDA,CADA,CACAA,oCAAAA,AAAoC,EAACK,EAAW9F,GAPzCqD,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,EAW5C,CACF,GAGA,OADAsH,EAA8B5K,GAAG,CAAC4F,EAAWiF,GACtCA,CACT,CAEA,SAAStI,EACPC,CAAoC,EAEpC,IAAMC,EAAqBJ,EAAmBvC,GAAG,CAAC0C,GAClD,GAAIC,EACF,OAAOA,EAGT,IAAMC,EAAUC,GAJQ,KAIAC,OAAO,CAACJ,GAGhC,OAFAH,EAAmBrC,GAAG,CAACwC,EAAwBE,GAExCA,CACT,CAkN0BgB,CAAAA,EAAAA,EAAAA,2CAAAA,AAA2C,EACnE4I,AAGF,SAASA,AACP7G,CAAyB,CACzBC,CAAkB,EAElB,IAAM6G,EAAS9G,EAAQ,CAAC,OAAO,EAAEA,EAAM,EAAE,CAAC,CAAG,cAC7C,OAAO,OAAA,cAIN,CAJU5I,AAAJ,MACL,CAAA,EAAG0P,EAAO,KAAK,EAAE7G,EAAW,uLAAE,CAAC,EAD1B,CAEH,CAAC,kBAFE,OAAA,mBAAA,gBAAA,CAIP,EACF,wDAH8H,CAAC,GACzH,CAAC,6CCxlBM8G,iBDwlBwD,CAAC,kBCxlBzDA,qCAAAA,KAAN,IAAMA,EACXpH,CAAAA,EAAAA,EAJsC,CAAA,CAAA,IAAA,GAItCA,uBAAAA,AAAuB,0GCMqBqH,4BAAAA,qCAArCD,EAAAA,iCAAiC,YAPQ,CAAA,CAAA,IAAA,yFCoClCE,sBAAsB,CAAA,kBAAtBA,GAiJAC,qCAAqC,CAAA,kBAArCA,GA/FHC,6BAA6B,CAAA,kBAA7BA,GAGGC,0BAA0B,CAAA,kBAA1BA,GA8CAC,kCAAkC,CAAA,kBAAlCA,+EAvIT,CAAA,CAAA,IAAA,OAGwB,CAAA,CAAA,IAAA,OAKxB,CAAA,CAAA,IAAA,OAWA,CAAA,CAAA,IAAA,OACwB,CAAA,CAAA,IAAA,OAIxB,CAAA,CAAA,IAAA,OAIA,CAAA,CAAA,IAAA,OACqD,CAAA,CAAA,IAAA,OAClB,CAAA,CAAA,IAAA,EAMnC,SAASJ,EACd1J,CAAwB,CACxB4C,CAAoB,EAEpB,IAAMgE,EAAgBC,EAAAA,oBAAoB,CAAC5D,QAAQ,GACnD,GAAI2D,EACF,OAAQA,EAAcE,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,OAAOiD,EACL/J,EACA4C,EACAgE,EAEJ,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIhC,EAAAA,cAAc,CACtB,kEADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,oBACH,MAAM,OAAA,cAEL,CAFK,IAAIA,EAAAA,cAAc,CACtB,uEADI,oBAAA,OAAA,kBAAA,iBAAA,CAEN,EACF,KAAK,UAaD,OAAOsF,EAAyBlK,EAItC,CAEFiH,CAAAA,EAAAA,EAAAA,6BAAAA,AAA6B,GAC/B,GAnD4B,CAAA,CAAA,IAAA,GAuDrB,IAAM2C,EAAgCE,EAGtC,SAASD,EACd7J,CAAwB,CACxB4C,CAAoB,EAEpB,IAAMgE,EAAgBC,EAAAA,oBAAoB,CAAC5D,QAAQ,GACnD,GAAI2D,EACF,OAAQA,EAAcE,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,OAAOiD,EACL/J,EACA4C,EACAgE,EAEJ,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIhC,EAAAA,cAAc,CACtB,sEADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,oBACH,OAAOuF,EAA6BnK,EAAkB4G,EACxD,KAAK,UAaD,OAAOsD,AA0KRnK,EA1KiCC,EAItC,CAEFiH,CAAAA,EAAAA,EAAAA,UAoK2BjH,mBApK3BiH,AAA6B,GAC/B,CAEO,SAAS6C,EACd9J,CAAwB,CACxB4C,CAAoB,EAEpB,IAAMgE,EAAgBC,EAAAA,oBAAoB,CAAC5D,QAAQ,GACnD,GAAI2D,EACF,OAAQA,EAAcE,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,OAAOiD,EACL/J,EACA4C,EACAgE,EAEJ,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIhC,EAAAA,cAAc,CACtB,8EADI,oBAAA,OAAA,mBAAA,eAAA,EAEN,EACF,KAAK,oBACH,OAAOuF,EAA6BnK,EAAkB4G,EACxD,KAAK,UAaD,OAAOsD,EAAyBlK,EAItC,CAEFiH,CAAAA,EAAAA,EAAAA,6BAAAA,AAA6B,GAC/B,CAEO,SAAS0C,EACd3J,CAAwB,EAExB,IAAM4C,EAAYwH,EAAAA,gBAAgB,CAACnH,QAAQ,GAC3C,GAAI,CAACL,EACH,MAAM,GADQ,IACR,cAEL,CAFK,IAAIgC,EAAAA,cAAc,CACtB,8DADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,GAGF,IAAMgC,EAAgBC,EAAAA,oBAAoB,CAAC5D,QAAQ,GACnD,GAAI2D,EACF,OAAQA,EAAcE,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBACH,IAAMuD,EAAiBzD,EAAc0D,mBAAmB,CACxD,GAAID,GACF,IAAK,IAAInJ,KADS,AACFlB,EACd,GAAIqK,EAAenX,GAAG,CAACgO,GAKrB,GAN8B,AACH,GAKpBkG,CAAAA,EAAAA,EAAAA,kBAAAA,AAAkB,EACvBR,EAAcS,YAAY,CAC1BzE,EAAUH,KAAK,CACf,WAGN,CAEF,KACF,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAImC,EAAAA,cAAc,CACtB,iFADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EAQJ,CAKF,OAAOjF,QAAQC,OAAO,CAACI,EACzB,CAEA,SAAS+J,EACP/J,CAAwB,CACxB4C,CAAoB,CACpB0E,CAAoC,EAEpC,OAAQA,EAAeR,IAAI,EACzB,IAAK,YACL,IAAK,mBAAoB,CACvB,IAAMuD,EAAiB/C,EAAegD,mBAAmB,CACzD,GAAID,GACF,IAAK,IAAMnJ,KADO,AACAlB,EAChB,GAAIqK,EAAenX,GAAG,CAACgO,GAKrB,GANgC,AACL,IA4GvC,AAvGmBqJ,SAuGVA,AACPvK,CAAwB,CACxB4C,CAAoB,CACpB0E,CAA0C,EAE1C,IAAMrH,EAAeH,EAAahD,GAAG,CAACkD,GACtC,GAAIC,EACF,OAAOA,EAGT,GAJkB,CAIZP,EAAU,IAAIoI,MAClBV,CAAAA,EAAAA,EAAAA,kBAAAA,AAAkB,EAChBE,EAAeD,YAAY,CAC3BzE,EAAUH,KAAK,CACf,YAEFkI,GAKF,OAFA7K,EAAa9C,GAAG,CAACgD,EAAkBN,GAE5BA,CACT,EA5HcM,EACA4C,EACA0E,EAGN,CAEF,KACF,CACA,IAAK,gBAAiB,CACpB,IAAM+C,EAAiB/C,EAAegD,mBAAmB,CACzD,GAAID,GACF,IAAK,IAAMnJ,KADO,AACAlB,EAChB,GAAIqK,EAAenX,GAAG,CAACgO,GACrB,GAD2B,AADK,IAEzBsJ,AAgHnB,SACExK,AADOwK,CACiB,CACxBH,CAAyC,CACzCzH,CAAoB,CACpB0E,CAAwD,EAExD,IAAMrH,EAAeH,EAAahD,GAAG,CAACkD,GACtC,GAAIC,EACF,OAAOA,EAGT,GAJkB,CAIZ+K,EAAsB,CAAE,GAAGhL,CAAgB,AAAC,EAK5CN,EAAUC,QAAQC,OAAO,CAACoL,GAwChC,OAvCAlL,EAAa9C,GAAG,CAACgD,EAAkBN,GAEnCqI,OAAOkB,IAAI,CAACjJ,GAAkBkJ,OAAO,CAAC,AAAC7I,IACjCuB,EAAAA,mBAAmB,CAAC1O,GAAG,CAACmN,IAItBgK,EAAenX,CAJc,EAIX,CAACmN,IACrB0H,GAD4B,IACrBkD,cAAc,CAACD,EAAqB3K,EAAM,CAC/CvD,MACE,IAAM4F,EAAaf,GAAAA,EAAAA,4BAAAA,AAA4B,EAAC,SAAUtB,GAO9B,iBAAiB,CAAzCiH,EAAeR,IAAI,CAErBqB,CAAAA,EAAAA,EAAAA,oBAAAA,AAAoB,EAClBvF,EAAUH,KAAK,CACfC,EACA4E,EAAec,eAAe,EAIhCC,CAAAA,EAAAA,EAAAA,gCAAAA,AAAgC,EAC9B3F,EACAE,EACA0E,EAGN,EACA4D,WAAY,EACd,EAGN,GAEOxL,CACT,EAxKcM,EACAqK,EACAzH,EACA0E,EAGN,CAGJ,CAKF,CAEA,OAAOvH,EAAoBC,EAC7B,CAEA,SAASmK,EACPnK,CAAwB,CACxB4G,CAA0C,EAE1C,MAAOa,CAAAA,EAAAA,EAAAA,sBAAAA,AAAsB,EAC3Bb,EACA7G,EAAoBC,GAExB,CA+BA,IAAMF,EAAe,IAAIR,QAEnBqL,EAA4D,CAChE7N,IAAK,SAASA,AAAIsD,CAAM,CAAEC,CAAI,CAAEC,CAAQ,EACtC,GAAa,SAATD,GAA4B,UAATA,GAA6B,YAATA,EAAoB,CAC7D,IAAMuK,EAAiBzK,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,GAExD,MAAO,EACL,CAACD,EAAK,CAAE,CAAC,GAAGgB,KACV,IAAMwJ,EAAQpB,EAAAA,yBAAyB,CAACxG,QAAQ,GAQhD,OANI4H,GACFA,EAAMC,EADG,aACY,CAACC,KAAK,CACzB,OAAA,cAA8D,CAA9D,AAAIlR,MAAM,CAAC,iDAAiD,CAA5D,AAA6D,oBAA7D,OAAA,mBAAA,gBAAA,CAA6D,IAI1D,IAAIiO,MACT8C,EAAerS,KAAK,CAAC6H,EAAQiB,GAC7BsJ,EAEJ,EACF,CAAA,AAAC,CAACtK,EAAK,AACT,CAEA,OAAOF,EAAAA,cAAc,CAACrD,GAAG,CAACsD,EAAQC,EAAMC,EAC1C,CACF,EAqFA,SAASP,EAAoBC,CAAwB,EACnD,IAAMC,EAAeH,EAAahD,GAAG,CAACkD,GACtC,GAAIC,EACF,OAAOA,EAGT,GAJkB,CAIZP,EAAUC,QAAQC,OAAO,CAACI,GAGhC,OAFAF,EAAa9C,GAAG,CAACgD,EAAkBN,GAE5BA,CACT,CAiG0BgB,CAAAA,EAAAA,EAAAA,2CAAAA,AAA2C,EACnE2K,AAGF,SAASA,AACP5I,CAAyB,CACzBC,CAAkB,EAElB,IAAM6G,EAAS9G,EAAQ,CAAC,OAAO,EAAEA,EAAM,EAAE,CAAC,CAAG,cAC7C,OAAO,OAAA,cAIN,CAJM,AAAI5I,MACT,CAAA,EAAG0P,EAAO,KAAK,EAAE7G,EAAW,iLAAE,CAAC,EAD1B,CAEH,CAAC,kBAFE,OAAA,mBAAA,eAAA,EAIP,EACF,kDAHwH,CAAC,GACnH,CAAC,kDC3hBS4I,YD2hBqD,CAAC,IC3hBtDA,qCAAAA,0BAhBe,CAAA,CAAA,IAAA,OAGK,CAAA,CAAA,IAAA,OAChB,CAAA,CAAA,IAAA,OAC4B,CAAA,CAAA,IAAA,OACZ,CAAA,CAAA,IAAA,GAU7B,SAASA,EAAe,WAC7B/Y,CAAS,CACTgZ,sBAAoB,CAQrB,EACC,IAAIC,EACAtR,EACJ,GAA6B,MAAM,CAA/BqR,EACFC,EAAeD,EAAqBC,YAAY,CAChDtR,EAASqR,EAAqBrR,MAAM,KAC/B,CAGL,IAAMuR,EAAsBlR,GAAAA,EAAAA,GAAAA,AAAG,EAACc,EAAAA,mBAAmB,EACnDnB,EAC0B,OAAxBuR,EAA+BA,EAAoBhQ,YAAY,CAAG,CAAC,EAOrE+P,EAAeE,CAAAA,EAAAA,EAAAA,+BAAAA,AAA+B,EAACnR,CAAAA,EAAAA,EAAAA,GAAAA,AAAG,EAACoR,EAAAA,mBAAmB,EACxE,CAEA,GAAsB,IAAlB,OAAO5U,OAAwB,CACjC,IAGI6U,EACA1L,EAJE,kBAAEkK,CAAgB,CAAE,CACxBlP,EAAQ,CAAA,CAAA,IAAA,GAMJ2P,EAAQT,EAAiBnH,QAAQ,GACvC,GAAI,CAAC4H,EACH,KADU,CACJ,OAAA,cAEL,CAFK,IAAIjG,EAAAA,cAAc,CACtB,4EADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,GAGF,GAAM,8BAAE4B,CAA4B,CAAE,CACpCtL,EAAQ,CAAA,CAAA,IAAA,GACV0Q,EAAqBpF,EAA6BgF,EAAcX,GAEhE,GAAM,CAAEnB,wBAAsB,CAAE,CAC9BxO,EAAQ,CAAA,CAAA,IAAA,GAGV,OAFAgF,AAEA,EAFewJ,EAAuBxP,EAAQ2Q,GAEvC,CAAA,CAAP,CAAO,EAAA,GAAA,EAACtY,EAAAA,CAAU2H,OAAQgG,EAAcsL,aAAcI,GACxD,CAAO,CACL,GAAM,oCAAExM,CAAkC,CAAE,CAC1ClE,EAAQ,CAAA,CAAA,IAAA,GACJ0Q,EAAqBxM,EAAmCoM,GACxD,8BAAE3L,CAA4B,CAAE,CACpC3E,EAAQ,CAAA,CAAA,IAAA,GACJgF,EAAeL,EAA6B3F,GAElD,MAAO,CAAP,AAAO,EAAA,EAAA,GAAA,EAAC3H,EAAR,AAAQA,CAAU2H,OAAQgG,EAAcsL,aAAcI,GACxD,CACF,+TCpEgBC,oBAAAA,qCAAAA,0BAde,CAAA,CAAA,IAAA,OAGK,CAAA,CAAA,IAAA,OAChB,CAAA,CAAA,IAAA,GAUb,SAASA,EAAkB,WAChCtZ,CAAS,OACTuZ,CAAK,sBACLP,CAAoB,CAQrB,EACC,IAAIrR,EACJ,GAA6B,MAAM,CAA/BqR,EACFrR,EAASqR,EAAqBrR,MAAM,KAC/B,CAGL,IAAMuR,EAAsBlR,CAAAA,EAAAA,EAAAA,GAAAA,AAAG,EAACc,EAAAA,mBAAmB,EACnDnB,EAC0B,OAAxBuR,EAA+BA,EAAoBhQ,YAAY,CAAG,CAAC,CACvE,CAEA,GAAsB,IAAlB,OAAO1E,OAAwB,CACjC,IAGImJ,EAHE,CAAEkK,kBAAgB,CAAE,CACxBlP,EAAQ,CAAA,CAAA,IAAA,GAKJ2P,EAAQT,EAAiBnH,QAAQ,GACvC,GAAI,CAAC4H,EACH,KADU,CACJ,OAAA,cAEL,CAFK,IAAIjG,EAAAA,cAAc,CACtB,sGADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,GAGF,GAAM,wBAAE8E,CAAsB,CAAE,CAC9BxO,EAAQ,CAAA,CAAA,IAAA,GAGV,OAFAgF,AAEA,EAFewJ,EAAuBxP,EAAQ2Q,GAEvC,CAAA,CAAP,CAAO,EAAA,GAAA,EAACtY,EAAAA,CAAW,GAAGuZ,CAAK,CAAE5R,OAAQgG,GACvC,CAAO,CACL,GAAM,8BAAEL,CAA4B,CAAE,CACpC3E,EAAQ,CAAA,CAAA,IAAA,GACJgF,EAAeL,EAA6B3F,GAClD,MAAO,CAAP,EAAO,EAAA,GAAA,EAAC3H,EAAR,AAAQA,CAAW,GAAGuZ,CAAK,CAAE5R,OAAQgG,GACvC,CACF,8TCxDa6L,WAAAA,qCAAAA,sBAAAA,EAAW,IACtB,AAAsB,IAAlB,OAAOhV,EAAwB,KAC1B,KAEF,CAAA,EAAA,EAAA,GAAA,EAAC9B,OAAAA,CAAKC,KAAK","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]}